#!/usr/bin/env python3
#
#

import argparse
import os
import copy
import glob
import json
import sys
import time
import traceback
from functools import partial
from struct import *

import graphviz
from PyQt5 import QtGui, QtSvg
from PyQt5.QtCore import QDateTime, QSize, Qt, QTimer
from PyQt5.QtGui import QColor, QFont, QStandardItem, QStandardItemModel
from PyQt5.QtWidgets import (
    QAbstractItemView,
    QApplication,
    QCheckBox,
    QComboBox,
    QDialog,
    QDialogButtonBox,
    QDoubleSpinBox,
    QFileDialog,
    QGridLayout,
    QHBoxLayout,
    QLabel,
    QLineEdit,
    QListWidget,
    QMessageBox,
    QPlainTextEdit,
    QPushButton,
    QScrollArea,
    QSlider,
    QSpinBox,
    QTableWidget,
    QTableWidgetItem,
    QTabWidget,
    QTreeView,
    QVBoxLayout,
    QWidget,
)

import riocore

riocore_path = os.path.dirname(riocore.__file__)

class MyStandardItem(QStandardItem):
    def __init__(self, txt="", font_size=12, set_bold=False, color=QColor(0, 0, 0), key=None, help_text=None):
        super().__init__()
        self.key = key
        if help_text:
            self.setToolTip(help_text)
        self.setEditable(False)
        self.setForeground(color)
        self.setText(txt)


class edit_float(QDoubleSpinBox):
    def __init__(self, win, obj, key, vmin=None, vmax=None, cb=None, help_text=None):
        super().__init__()
        self.win = win
        self.cb = cb
        self.obj = obj
        self.key = key
        if help_text:
            self.setToolTip(help_text)
        if vmin:
            self.setMinimum(vmin)
        else:
            self.setMinimum(-999999)
        if vmax:
            self.setMaximum(vmax)
        else:
            self.setMaximum(999999)
        if key in obj:
            self.setValue(float(obj[key]))
        self.editingFinished.connect(self.change)

    def change(self):
        self.obj[self.key] = self.value()
        if self.cb:
            self.cb(self.value())
        self.win.display()


class edit_int(QSpinBox):
    def __init__(self, win, obj, key, vmin=None, vmax=None, cb=None, help_text=None):
        super().__init__()
        self.win = win
        self.cb = cb
        self.obj = obj
        self.key = key
        if help_text:
            self.setToolTip(help_text)
        if vmin:
            self.setMinimum(vmin)
        else:
            self.setMinimum(-999999)
        if vmax:
            self.setMaximum(vmax)
        else:
            self.setMaximum(999999)
        if key in obj:
            self.setValue(int(obj[key]))
        self.editingFinished.connect(self.change)

    def change(self):
        self.obj[self.key] = self.value()
        if self.cb:
            self.cb(self.value())
        self.win.display()


class edit_text(QLineEdit):
    def __init__(self, win, obj, key, cb=None, help_text=None):
        super().__init__()
        self.win = win
        self.cb = cb
        self.obj = obj
        self.key = key
        if help_text:
            self.setToolTip(help_text)
        if key in obj:
            self.setText(str(obj[key]))
        self.textChanged.connect(self.change)

    def change(self):
        self.obj[self.key] = self.text()
        if self.cb:
            self.cb(self.text())
        self.win.display()


class edit_bool(QCheckBox):
    def __init__(self, win, obj, key, cb=None, help_text=None):
        super().__init__()
        self.win = win
        self.cb = cb
        self.obj = obj
        self.key = key
        if help_text:
            self.setToolTip(help_text)
        if key in obj:
            self.setChecked(obj[key])
        self.stateChanged.connect(self.change)

    def change(self):
        self.obj[self.key] = self.isChecked()
        if self.cb:
            self.cb(self.text())
        self.win.display()


class edit_combobox(QComboBox):
    def __init__(self, win, obj, key, options, cb=None, help_text=None):
        super().__init__()
        self.win = win
        self.cb = cb
        self.obj = obj
        self.key = key
        options = options.copy()
        if help_text:
            self.setToolTip(help_text)
        if key in obj:
            if obj[key] not in options:
                options.append(obj[key])
        else:
            options.append("")
        for option in options:
            self.addItem(option)
        self.setEditable(True)
        if key in obj:
            self.setCurrentIndex(options.index(obj[key]))
        else:
            self.setCurrentIndex(options.index(""))
        self.activated.connect(self.change)

    def change(self):
        self.obj[self.key] = self.currentText()
        if self.cb:
            self.cb(self.currentText())
        self.win.display()

class modifier_selector(QComboBox):
    def __init__(self, win, pin_setup, modifier_id, modifier_view, help_text=None):
        super().__init__()
        self.win = win
        self.pin_setup = pin_setup
        self.modifier_id = modifier_id
        self.modifier_view = modifier_view
        self.entrys = list(set(riocore.plugins.Modifiers().pin_modifier_list()))
        self.entrys.append("--delete--")
        if help_text:
            self.setToolTip(help_text)
        for entry in self.entrys:
            self.addItem(entry)
        active = pin_setup["modifier"][self.modifier_id]["type"]
        self.setCurrentIndex(self.entrys.index(active))
        self.setEditable(False)
        self.activated.connect(self.change)

    def change(self):
        selected = self.currentText()
        if selected == "--delete--":
            del self.pin_setup["modifier"][self.modifier_id]
            parent = self.modifier_view.parent()
            while parent.rowCount() > 0:
                parent.removeRow(0)
            for modifier_id, modifier in enumerate(self.pin_setup.get("modifier", [])):
                self.win.tree_add_modifier(parent, self.pin_setup, modifier_id, modifier)
        else:
            self.pin_setup["modifier"][self.modifier_id]["type"] = selected
        self.win.display()


class WinForm(QWidget):
    def __init__(self, args, parent=None):
        super(WinForm, self).__init__(parent)
        self.setWindowTitle(f"LinuxCNC-RIO - Setup-GUI")
        self.setMinimumWidth(1400)
        self.setMinimumHeight(900)

        self.listFile = QListWidget()
        layout = QGridLayout()
        self.setLayout(layout)

        self.treeview = QTreeView()
        # self.treeview.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.model = QStandardItemModel()
        self.model.setHorizontalHeaderLabels(["Name", "Value"])
        self.model.itemChanged.connect(self.itemChanged)
        self.treeview.setModel(self.model)
        self.treeview.setUniformRowHeights(True)

        if os.path.isfile(args.config):
            self.config_file = args.config
        elif os.path.isfile(f"{riocore_path}/configs/{args.config}"):
            self.config_file = f"{riocore_path}/configs/{args.config}"
        else:
            print(f"can not load: {args.config}")
            exit(1)
        print(f"loading: {self.config_file}")

        row = 0

        layout.addWidget(self.treeview, row, 0)

        tabwidget = QTabWidget()
        layout.addWidget(tabwidget, row, 1)

        self.pin_table = QTableWidget()
        self.pin_table.setColumnCount(6)
        self.pin_table.setHorizontalHeaderItem(0, QTableWidgetItem("Pin"))
        self.pin_table.setHorizontalHeaderItem(1, QTableWidgetItem("Plugin"))
        self.pin_table.setHorizontalHeaderItem(2, QTableWidgetItem("Pin-Name"))
        self.pin_table.setHorizontalHeaderItem(3, QTableWidgetItem("Mapping"))
        self.pin_table.setHorizontalHeaderItem(4, QTableWidgetItem("Direction"))
        self.pin_table.setHorizontalHeaderItem(5, QTableWidgetItem("Comment"))

        self.imagew = QtSvg.QSvgWidget()

        scroll = QScrollArea()
        scroll.setWidget(self.imagew)
        scroll.setWidgetResizable(True)
        tabwidget.addTab(scroll, "Flow")
        tabwidget.addTab(self.pin_table, "Pintable")

        self.jsonpreview = QPlainTextEdit()
        self.jsonpreview.clear()
        self.jsonpreview.insertPlainText("...")
        self.jsonpreview.verticalScrollBar().setValue(0)
        tabwidget.addTab(self.jsonpreview, "Json-Preview")

        gateware_tabwidget = QTabWidget()
        tabwidget.addTab(gateware_tabwidget, "Gateware")

        linuxcnc_tabwidget = QTabWidget()
        tabwidget.addTab(linuxcnc_tabwidget, "LinuxCNC")

        self.gateware = {
            "rio.v": QPlainTextEdit(),
            "Makefile": QPlainTextEdit(),
        }
        self.linuxcnc = {
            "rio.ini": QPlainTextEdit(),
            "rio.hal": QPlainTextEdit(),
            "custom_postgui.hal": QPlainTextEdit(),
            "rio-gui.xml": QPlainTextEdit(),
            "rio.c": QPlainTextEdit(),
        }

        for filename, widget in self.gateware.items():
            widget.clear()
            widget.insertPlainText("Please press generate ...")
            widget.verticalScrollBar().setValue(0)
            gateware_tabwidget.addTab(widget, filename)
        for filename, widget in self.linuxcnc.items():
            widget.clear()
            widget.insertPlainText("Please press generate ...")
            widget.verticalScrollBar().setValue(0)
            linuxcnc_tabwidget.addTab(widget, filename)

        row += 1

        container = QWidget()
        button_layout = QHBoxLayout(container)
        layout.addWidget(container, row, 1)

        self.info_widget = QLabel("loading...")
        layout.addWidget(self.info_widget, row, 0)

        button = QPushButton("Save")
        button.clicked.connect(self.save_config)
        button_layout.addWidget(button)

        button = QPushButton("Generate")
        button.clicked.connect(self.generate)
        button_layout.addWidget(button)

        button = QPushButton("reload tree")
        button.clicked.connect(self.load_tree)
        button_layout.addWidget(button)

        button = QPushButton("reload config")
        button.clicked.connect(self.config_load)
        button_layout.addWidget(button)

        row += 1

        self.json_load()
        self.config_load()
        # self.load_tree()
        # self.display()

    def itemChanged(self, item):
        pass
        # print("itemChanged")
        # if hasattr(item, "edit"):
        #    item.edit(item)

    def json_load(self):
        # loading json config
        configJsonStr = open(self.config_file, "r").read()
        self.config = json.loads(configJsonStr)

    def setup_merge(self, setup, defaults):
        for key, value in defaults.items():
            if key not in setup:
                setup[key] = copy.deepcopy(value)
            elif isinstance(value, dict):
                self.setup_merge(setup[key], value)

    def get_path(self, path):
        if os.path.exists(path):
            return path
        elif os.path.exists(f"{riocore_path}/{path}"):
            return f"{riocore_path}/{path}"
        print(f"can not find path: {path}")
        exit(1)

    def config_load(self):
        self.info_widget.setText(self.config_file)

        # loading board config
        boardcfg = self.config.get("boardcfg")
        if boardcfg:
            board_file = self.get_path(f"boards/{boardcfg}.json")
            self.board = {}
            boardJsonStr = open(board_file, "r").read()
            self.board = json.loads(boardJsonStr)

        slot_pinmapping = {}
        for slot in self.board.get("slots", []):
            slot_name = slot["name"]
            for pin_id, pin in slot["pins"].items():
                pin_name = f"{slot_name}:{pin_id}"
                slot_pinmapping[pin] = pin_name

        # loading slot/module configs
        self.modules = {}
        for module in self.config.get("modules", []):
            slot_name = module.get("slot")
            module_name = module.get("module")
            module_setup = module.get("setup", {})
            module_path = self.get_path(f"modules/{module_name}.json")
            moduleJsonStr = open(module_path, "r").read()
            module_defaults = json.loads(moduleJsonStr)

            mplugins = riocore.Plugins()
            for plugin_id, plugin_config in enumerate(module_defaults.get("plugins", [])):
                plugin_type = plugin_config.get("type")
                plugin_name = plugin_config.get("name")
                if plugin_name not in module_setup:
                    module_setup[plugin_name] = {}
                self.setup_merge(module_setup[plugin_name], plugin_config)
                if "pins" in module_setup[plugin_name]:
                    for pin in module_setup[plugin_name]["pins"]:
                        module_setup[plugin_name]["pins"][pin]["pin_mapped"] = module_setup[plugin_name]["pins"][pin]["pin"]
                        del module_setup[plugin_name]["pins"][pin]["pin"]

                mplugins.load_plugin(plugin_id, module_setup[plugin_name], self.config)

            self.modules[slot_name] = {
                "defaults": module_defaults,
                "setup": module_setup,
                "instances": mplugins.plugin_instances,
            }

        # loading plugins
        self.plugins = riocore.Plugins()
        for plugin_id, plugin_config in enumerate(self.config.get("plugins", [])):
            plugin_type = plugin_config.get("type")
            self.plugins.load_plugin(plugin_id, plugin_config, self.config)

        self.items = {}

        self.pinlist = []
        self.pinmapping = {}
        self.pinmapping_rev = {}
        for plugin_instance in self.plugins.plugin_instances:
            name = plugin_instance.plugin_setup.get("name")
            title = plugin_instance.NAME
            if name:
                title = f"{name} ({plugin_instance.NAME})"
            for pin_name, pin_defaults in plugin_instance.PINDEFAULTS.items():
                pin_setup = plugin_instance.plugin_setup.get("pins", {}).get(pin_name, {})
                if not pin_setup and pin_defaults.get("optional") is True:
                    continue
                pin = pin_setup["pin"]
                if pin not in self.pinlist:
                    self.pinlist.append(pin)
        for slot in self.board.get("slots", []):
            slot_name = slot.get("name")
            slot_pins = slot.get("pins", {})
            for pin_name, pin in slot_pins.items():
                pin_id = f"{slot_name}:{pin_name}"
                if pin not in self.pinlist:
                    self.pinlist.append(pin)
                self.pinmapping[pin_id] = pin
                self.pinmapping_rev[pin] = pin_id
                if pin_id not in self.pinlist:
                    self.pinlist.append(pin_id)

        # TODO: add expansion pins
        self.pinlist.sort()

        boards_path = self.get_path(f"boards/")
        modules_path = self.get_path(f"modules/")

        self.interfaces = []
        for path in glob.glob(f"{riocore_path}/interfaces/*"):
            self.interfaces.append(path.split("/")[-1])
        self.boards = []
        for path in glob.glob(f"{boards_path}/*.json"):
            self.boards.append(path.split("/")[-1].split(".")[0])
        self.module_names = []
        for path in glob.glob(f"{modules_path}/*.json"):
            self.module_names.append(path.split("/")[-1].split(".")[0])
        self.slots = []
        for slot in self.board.get("slots", []):
            slot_name = slot.get("name")
            if slot_name:
                self.slots.append(slot_name)

        self.load_tree()
        self.display()

    def display(self):
        self.overview_load()
        self.pin_table_load()
        self.json_preview()

    def json_preview(self):
        config = copy.deepcopy(self.config)
        # cleanup
        for module in config.get("modules", []):
            slot_name = module.get("slot")
            module_name = module.get("module")
            module_setup = module.get("setup")
            module_path = self.get_path(f"modules/{module_name}.json")
            moduleJsonStr = open(module_path, "r").read()
            module_defaults = json.loads(moduleJsonStr)
            for name, setup in module.get("setup", {}).items():
                for pin, pin_setup in setup.get("pins", {}).items():
                    del pin_setup["pin_mapped"]

        self.jsonpreview.clear()
        self.jsonpreview.insertPlainText(json.dumps(config, indent=4))
        self.jsonpreview.verticalScrollBar().setValue(0)

    def overview_load(self):
        num = 0
        in_use = set()

        fpga_name = f"{self.config.get('boardcfg')}"

        gAll = graphviz.Digraph("G", format="svg")
        gAll.attr(rankdir="LR")
        gAll.attr(bgcolor="black")

        sportsr = []
        sportsl = []

        # show slots
        for slot in self.board.get("slots", []):
            slot_name = slot.get("name")
            slot_pins = slot.get("pins", {})
            mportsl = []
            mportsr = []
            for pin_name, pin in slot_pins.items():
                pin_id = f"{slot_name}_{pin_name}"
                mportsl.append(f"<{pin}>{pin}")
                mportsr.append(f"<{pin_id}>{pin_name}")

            label = f"{{ {{{' | '.join(mportsl)}}} | {slot_name} | {{{' | '.join(mportsr)}}} }}"
            sportsr.append(label)

        for plugin_instance in self.plugins.plugin_instances:
            pports = []
            name = plugin_instance.plugin_setup.get("name", plugin_instance.title)
            title = plugin_instance.NAME
            if name:
                title = f"{name} ({plugin_instance.NAME})"

            if plugin_instance.TYPE == "expansion":
                title = plugin_instance.expansion_prefix

            for pin_name, pin_defaults in plugin_instance.PINDEFAULTS.items():
                pin_setup = plugin_instance.plugin_setup.get("pins", {}).get(pin_name, {})
                pports.append(f"<{pin_name}>{pin_name}")
                if not pin_setup and pin_defaults.get("optional") is True:
                    continue
                pin = pin_setup["pin"]

                con_dev = fpga_name
                con_pin = pin
                if pin.startswith("EXPANSION"):
                    con_dev = pin.split("_")[0]
                    con_pin = pin.split("_")[1].replace("[", "").replace("]", "")

                if ":" in con_pin:
                    con_pin = con_pin.replace(":", "_")

                if pin_defaults["direction"] == "input":
                    modifiers = pin_setup.get("modifier", [])
                    if modifiers:
                        modifiers = reversed(modifiers)
                    color = "green"
                    arrow_dir = "back"
                else:
                    modifiers = pin_setup.get("modifier", [])
                    color = "red"
                    arrow_dir = "forward"

                if modifiers:
                    modifier_chain = []
                    for modifier_num, modifier in enumerate(modifiers):
                        modifier_type = modifier["type"]
                        modifier_chain.append(modifier_type)
                    modifier_label = f"{{ <l> | {' | '.join(modifier_chain)} | <r> }}"
                    gAll.edge(f"{con_dev}:{con_pin}", f"{name}_{modifier_type}_{modifier_num}:l", dir=arrow_dir, color=color)
                    con_dev = f"{name}_{modifier_type}_{modifier_num}"
                    con_pin = "r"
                    gAll.node(
                        f"{name}_{modifier_type}_{modifier_num}",
                        shape="record",
                        label=modifier_label,
                        fontsize="11pt",
                        style="rounded, filled",
                        fillcolor="lightyellow",
                    )

                gAll.edge(f"{con_dev}:{con_pin}", f"{title}:{pin_name}", dir=arrow_dir, color=color)

                if ":" not in pin and not pin.startswith("EXPANSION"):
                    sportsr.append(f"<{pin}>{pin}")

                num += 1

            net = plugin_instance.plugin_setup.get("net")
            if net:
                print(f"WARNING: net moved into signals: {title} / {net}")
                gAll.edge(f"{title}", f"{net}", dir="none", color="white", fontcolor="white")
                gAll.node(
                    net,
                    shape="record",
                    label=net,
                    fontsize="11pt",
                    style="rounded, filled",
                    fillcolor="lightpink",
                )

            signalports = []
            for signal_name, signal_config in plugin_instance.plugin_setup.get("signals", {}).items():
                net = signal_config.get("net")
                function = signal_config.get("function")
                signalports.append(f"<signal_{signal_name}>{signal_name}")
                signal_direction = plugin_instance.SIGNALS.get(signal_name, {}).get("direction")
                direction_mapping = {"input": "normal", "output": "back", "inout": "both"}
                if function:
                    gAll.edge(f"{title}:signal_{signal_name}", f"{function}", dir=direction_mapping.get(signal_direction, "none"), color="white", fontcolor="white")
                    gAll.node(
                        function,
                        shape="record",
                        label=function,
                        fontsize="11pt",
                        style="rounded, filled",
                        fillcolor="lightpink",
                    )
                if net:
                    gAll.edge(f"{title}:signal_{signal_name}", f"{net}", dir=direction_mapping.get(signal_direction, "none"), color="white", fontcolor="white")
                    gAll.node(
                        net,
                        shape="record",
                        label=net,
                        fontsize="11pt",
                        style="rounded, filled",
                        fillcolor="lightpink",
                    )

            if plugin_instance.TYPE == "expansion":
                bits = plugin_instance.plugin_setup.get("bits", 8)

                eports = []
                for n in range(bits):
                    eports.append(f"<INPUT{n}>INPUT[{n}]")
                for n in range(bits):
                    eports.append(f"<OUTPUT{n}>OUTPUT[{n}]")

                label = f"{{ {{{' | '.join(pports)}}} | {title} | {{{' | '.join(eports)}}} }}"

            elif signalports:
                label = f"{{ {{{' | '.join(pports)}}} | {title} | {{{' | '.join(signalports)}}} }}"
            else:
                label = f"{{ {{{' | '.join(pports)}}} | {title} }}"

            gAll.node(
                title,
                shape="record",
                label=label,
                fontsize="11pt",
                style="rounded, filled",
                fillcolor="lightblue",
            )

        for module_data in self.config.get("modules", []):
            slot_name = module_data.get("slot")
            module_name = module_data.get("module")
            title = slot_name
            if module_name:
                title = f"{module_name} ({title})"

            for plugin_instance in self.modules[slot_name]["instances"]:
                pports = []
                name = plugin_instance.plugin_setup.get("name")
                title = plugin_instance.NAME
                if name:
                    title = f"{name} ({plugin_instance.NAME})"
                for pin_name, pin_defaults in plugin_instance.PINDEFAULTS.items():
                    pin_setup = plugin_instance.plugin_setup.get("pins", {}).get(pin_name, {})
                    if "pin_mapped" not in pin_setup:
                        continue

                    # pin = self.pinmapping[f"{slot_name}:{pin_setup['pin_mapped']}"]
                    pin = f"{slot_name}_{pin_setup['pin_mapped']}"

                    con_dev = fpga_name
                    con_pin = pin
                    if pin.startswith("EXPANSION"):
                        con_dev = pin.split("_")[0]
                        con_pin = pin.split("_")[1].replace("[", "").replace("]", "")

                    if pin_defaults["direction"] == "input":
                        modifiers = pin_setup.get("modifier", [])
                        if modifiers:
                            modifiers = reversed(modifiers)
                        color = "green"
                        arrow_dir = "back"
                    else:
                        modifiers = pin_setup.get("modifier", [])
                        color = "red"
                        arrow_dir = "forward"

                    if modifiers:
                        modifier_chain = []
                        for modifier_num, modifier in enumerate(modifiers):
                            modifier_type = modifier["type"]
                            modifier_chain.append(modifier_type)
                        modifier_label = f"{{ <l> | {' | '.join(modifier_chain)} | <r> }}"
                        gAll.edge(f"{con_dev}:{con_pin}", f"{name}_{modifier_type}_{modifier_num}:l", dir=arrow_dir, color=color)
                        con_dev = f"{name}_{modifier_type}_{modifier_num}"
                        con_pin = "r"
                        gAll.node(
                            f"{name}_{modifier_type}_{modifier_num}",
                            shape="record",
                            label=modifier_label,
                            fontsize="11pt",
                            style="rounded, filled",
                            fillcolor="lightyellow",
                        )

                    gAll.edge(f"{con_dev}:{con_pin}", f"{title}:{pin_name}", dir=arrow_dir, color=color)
                    pports.append(f"<{pin_name}>{pin_name}")

                net = plugin_instance.plugin_setup.get("net")
                if net:
                    gAll.edge(f"{title}", f"{net}", dir="none", color="white", fontcolor="white")
                    gAll.node(
                        net,
                        shape="record",
                        label=net,
                        fontsize="11pt",
                        style="rounded, filled",
                        fillcolor="lightpink",
                    )

                signalports = []
                for signal_name, signal_config in plugin_instance.plugin_setup.get("signals", {}).items():
                    net = signal_config.get("net")
                    function = signal_config.get("function")
                    signalports.append(f"<signal_{signal_name}>{signal_name}")
                    signal_direction = plugin_instance.SIGNALS.get(signal_name, {}).get("direction")
                    direction_mapping = {"input": "forward", "output": "back", "inout": "both"}
                    if function:
                        gAll.edge(f"{title}:signal_{signal_name}", f"{function}", dir=direction_mapping.get(signal_direction, "none"), color="white", fontcolor="white")
                        gAll.node(
                            function,
                            shape="record",
                            label=function,
                            fontsize="11pt",
                            style="rounded, filled",
                            fillcolor="lightpink",
                        )
                    if net:
                        gAll.edge(f"{title}:signal_{signal_name}", f"{net}", dir=direction_mapping.get(signal_direction, "none"), color="white", fontcolor="white")
                        gAll.node(
                            net,
                            shape="record",
                            label=net,
                            fontsize="11pt",
                            style="rounded, filled",
                            fillcolor="lightpink",
                        )

                if signalports:
                    label = f"{{ {{{' | '.join(pports)}}} | {title} | {{{' | '.join(signalports)}}} }}"
                else:
                    label = f"{{ {{{' | '.join(pports)}}} | {title} }}"
                gAll.node(
                    title,
                    shape="record",
                    label=label,
                    fontsize="11pt",
                    style="rounded, filled",
                    fillcolor="lightblue",
                )


        label = f"{{ {{{' | '.join(sportsl)}}} | {fpga_name} | {{{' | '.join(sportsr)}}} }}"
        gAll.node(f"{fpga_name}", shape="record", label=label, fontsize="11pt", style="rounded, filled", fillcolor="yellow")

        self.imagew.load(gAll.pipe().decode().encode())

        # self.imagew.setFixedSize(QSize(800, 600))
        # self.imagew.setFixedSize(self.imagew.renderer().defaultSize())

    def pin_table_load(self):
        self.pin_table.setRowCount(0)
        num = 0
        in_use = set()

        for plugin_instance in self.plugins.plugin_instances:
            name = plugin_instance.plugin_setup.get("name")
            title = plugin_instance.NAME
            if name:
                title = f"{name} ({plugin_instance.NAME})"

            for pin_name, pin_defaults in plugin_instance.PINDEFAULTS.items():
                pin_setup = plugin_instance.plugin_setup.get("pins", {}).get(pin_name, {})
                if not pin_setup and pin_defaults.get("optional") is True:
                    continue
                pin = pin_setup["pin"]
                in_use.add(pin)
                self.pin_table.setRowCount(num + 1)
                pitem = QTableWidgetItem(pin)
                self.pin_table.setItem(num, 0, pitem)
                titem = QTableWidgetItem(title)
                self.pin_table.setItem(num, 1, titem)
                nitem = QTableWidgetItem(pin_name)
                self.pin_table.setItem(num, 2, nitem)
                if pin in self.pinmapping_rev:
                    mitem = QTableWidgetItem(self.pinmapping_rev[pin])
                    self.pin_table.setItem(num, 3, mitem)
                elif pin in self.pinmapping:
                    mitem = QTableWidgetItem(self.pinmapping[pin])
                    self.pin_table.setItem(num, 3, mitem)

                ditem = QTableWidgetItem(pin_defaults["direction"])
                self.pin_table.setItem(num, 4, ditem)
                modifiers = pin_setup.get("modifier")
                if modifiers:
                    mlist = set()
                    for modifier in modifiers:
                        mlist.add(modifier["type"])
                    ditem = QTableWidgetItem(f"{','.join(mlist)}")
                    self.pin_table.setItem(num, 5, ditem)

                num += 1

        for module_data in self.config.get("modules", []):
            slot_name = module_data.get("slot")
            module_name = module_data.get("module")
            title = slot_name
            if module_name:
                title = f"{module_name} ({title})"

            for plugin_instance in self.modules[slot_name]["instances"]:
                name = plugin_instance.plugin_setup.get("name")
                title = plugin_instance.NAME
                if name:
                    title = f"{name} ({plugin_instance.NAME})"
                for pin_name, pin_defaults in plugin_instance.PINDEFAULTS.items():
                    pin_setup = plugin_instance.plugin_setup.get("pins", {}).get(pin_name, {})
                    if "pin_mapped" not in pin_setup:
                        continue

                    # TODO: remove pin_mapped while saving
                    pin_str = f"{slot_name}:{pin_setup['pin_mapped']}"
                    if pin_str not in self.pinmapping:
                        continue
                    pin = self.pinmapping[pin_str]

                    in_use.add(pin)
                    self.pin_table.setRowCount(num + 1)
                    pitem = QTableWidgetItem(pin)
                    self.pin_table.setItem(num, 0, pitem)
                    titem = QTableWidgetItem(title)
                    self.pin_table.setItem(num, 1, titem)
                    nitem = QTableWidgetItem(pin_name)
                    self.pin_table.setItem(num, 2, nitem)
                    if pin in self.pinmapping_rev:
                        mitem = QTableWidgetItem(self.pinmapping_rev[pin])
                        self.pin_table.setItem(num, 3, mitem)
                    elif pin in self.pinmapping:
                        mitem = QTableWidgetItem(self.pinmapping[pin])
                        self.pin_table.setItem(num, 3, mitem)

                    ditem = QTableWidgetItem(pin_defaults["direction"])
                    self.pin_table.setItem(num, 4, ditem)
                    modifiers = pin_setup.get("modifier")
                    if modifiers:
                        mlist = set()
                        for modifier in modifiers:
                            mlist.add(modifier["type"])
                        ditem = QTableWidgetItem(f"{','.join(mlist)}")
                        self.pin_table.setItem(num, 5, ditem)
                    num += 1

        for pin in self.pinlist:
            if pin not in in_use:
                if pin in self.pinmapping:
                    continue
                if pin in self.pinmapping_rev:
                    if self.pinmapping_rev[pin] in in_use:
                        continue
                self.pin_table.setRowCount(num + 1)
                pitem = QTableWidgetItem(pin)
                self.pin_table.setItem(num, 0, pitem)
                titem = QTableWidgetItem("")
                self.pin_table.setItem(num, 1, titem)
                nitem = QTableWidgetItem("")
                self.pin_table.setItem(num, 2, nitem)
                if pin in self.pinmapping_rev:
                    mitem = QTableWidgetItem(self.pinmapping_rev[pin])
                    self.pin_table.setItem(num, 3, mitem)
                num += 1
        self.pin_table.resizeColumnToContents(0)

    def edit_item(self, obj, key, var_setup=None, cb=None):
        if var_setup is None:
            var_setup = {}
        if key not in obj and "default" in var_setup:
            obj[key] = var_setup["default"]
        if var_setup["type"] == "select":
            return edit_combobox(self, obj, key, var_setup.get("options", []), cb=cb)
        elif var_setup["type"] == int:
            return edit_int(self, obj, key, vmin=var_setup.get("min"), vmax=var_setup.get("max"), cb=cb)
        elif var_setup["type"] == float:
            return edit_float(self, obj, key, vmin=var_setup.get("min"), vmax=var_setup.get("max"), cb=cb)
        elif var_setup["type"] == bool:
            return edit_bool(self, obj, key, cb=cb)
        return edit_text(self, obj, key, cb=cb)

    def load_tree(self):
        while self.model.rowCount() > 0:
            self.model.removeRow(0)

        for key, var_setup in {
            "name": {"type": str},
            "description": {"type": str},
            "boardcfg": {"type": "select", "options": self.boards},
            "transport": {"type": "select", "options": self.interfaces, "default": "UDP"},
            "axis": {"type": int, "min": 0, "max": 9, "default": 3},
        }.items():
            aitem = QStandardItem()
            self.model.appendRow(
                [
                    MyStandardItem(key.title()),
                    aitem,
                ]
            )
            self.treeview.setIndexWidget(aitem.index(), self.edit_item(self.config, key, var_setup))


        bitem = QStandardItem()
        self.model.appendRow(
            [
                MyStandardItem("Modules", help_text="Module-Configuration"),
                bitem,
            ]
        )
        tree_modules = self.model.item(self.model.rowCount() - 1)

        button = QPushButton("add module")
        button.clicked.connect(self.add_module)
        button.setMaximumSize(button.sizeHint())
        self.treeview.setIndexWidget(bitem.index(), button)
        self.treeview.expand(self.model.indexFromItem(tree_modules))

        for module_data in self.config.get("modules", []):
            slot_name = module_data.get("slot")
            module_name = module_data.get("module")
            title = slot_name
            if module_name:
                title = f"{module_name} ({title})"
            aitem = QStandardItem()
            tree_modules.appendRow(
                [
                    MyStandardItem(title),
                    MyStandardItem(""),
                ]
            )
            module_view = tree_modules.child(tree_modules.rowCount() - 1)
            self.treeview.expand(self.model.indexFromItem(module_view))

            for key, var_setup in {
                "module": {"type": "select", "options": self.module_names},
                "slot": {"type": "select", "options": self.slots},
            }.items():
                aitem = QStandardItem()
                module_view.appendRow(
                    [
                        MyStandardItem(key.title()),
                        aitem,
                    ]
                )
                self.treeview.setIndexWidget(aitem.index(), self.edit_item(module_data, key, var_setup, cb=self.slot_change))

            module_plugins_view = MyStandardItem("Plugins")
            module_view.appendRow(module_plugins_view)

            # self.treeview.expand(self.model.indexFromItem(module_plugins_view))

            for plugin_instance in self.modules[slot_name]["instances"]:
                self.tree_add_plugin(module_plugins_view, plugin_instance, nopins=True, expand=False)

        bitem = QStandardItem()
        self.model.appendRow(
            [
                MyStandardItem("Plugins"),
                bitem,
            ]
        )
        self.tree_plugins = self.model.item(self.model.rowCount() - 1)

        button = QPushButton("add plugin")
        button.clicked.connect(self.add_plugin)
        button.setMaximumSize(button.sizeHint())
        self.treeview.setIndexWidget(bitem.index(), button)
        self.treeview.expand(self.model.indexFromItem(self.tree_plugins))

        for plugin_instance in self.plugins.plugin_instances:
            self.tree_add_plugin(self.tree_plugins, plugin_instance)

        self.treeview.header().resizeSection(0, 300)
        self.treeview.header().resizeSection(1, 200)

    def slot_change(self, widget):
        self.config_load()

    def add_modifier(self, parent, pin_setup):
        if "modifier" not in pin_setup:
            pin_setup["modifier"] = []
        modifier_id = len(pin_setup.get("modifier", []))
        pin_setup["modifier"].append({"type": "invert"})
        modifier = pin_setup["modifier"][-1]
        self.tree_add_modifier(parent, pin_setup, modifier_id, modifier)
        self.display()

    def add_plugin(self, widget):
        plugin_type = self.select_plugin()
        if not plugin_type:
            return
        plugin_id = len(self.config["plugins"])
        self.config["plugins"].append(
            {
                "type": plugin_type,
                "pins": {},
            }
        )
        plugin_instance = self.plugins.load_plugin(plugin_id, self.config["plugins"][plugin_id], self.config)
        if plugin_instance:
            for pin_name, pin_defaults in plugin_instance.PINDEFAULTS.items():
                self.config["plugins"][plugin_id]["pins"][pin_name] = {"pin": "xxx"}
            self.tree_add_plugin(self.tree_plugins, plugin_instance, expand=True)
        self.display()

    def add_module(self, widget):
        while True:
            print("select")
            slot_name, module_name = self.select_module()
            if not module_name or not slot_name:
                print("cancel")
                return

            module_path = self.get_path(f"modules/{module_name}.json")
            moduleJsonStr = open(module_path, "r").read()
            module_defaults = json.loads(moduleJsonStr)

            slot_setup = {}
            for slot in self.board.get("slots", []):
                if slot_name == slot["name"]:
                    slot_setup = slot
            slot_pins = slot_setup.get("pins", {})

            check = True
            for plugin in module_defaults.get("plugins"):
                for pin_name, pin_config in plugin.get("pins", {}).items():
                    pin_location = pin_config.get("pin")
                    print(pin_location , slot_pins)
                    if pin_location not in slot_pins:
                        check = False

            if check is True:
                break
            else:
                print("ERROR: module/slot is not compatible")

        if "modules" not in self.config:
            self.config["modules"] = []

        module_id = len(self.config["modules"])
        module_setup = {}
        self.config["modules"].append(
            {
                "slot": slot_name,
                "module": module_name,
                "setup": module_setup,
            }
        )
        print("module_instance", self.config["modules"])

        mplugins = riocore.Plugins()
        for plugin_id, plugin_config in enumerate(module_defaults.get("plugins", [])):
            plugin_type = plugin_config.get("type")
            plugin_name = plugin_config.get("name")
            if plugin_name not in module_setup:
                module_setup[plugin_name] = {}
            self.setup_merge(module_setup[plugin_name], plugin_config)
            if "pins" in module_setup[plugin_name]:
                for pin in module_setup[plugin_name]["pins"]:
                    module_setup[plugin_name]["pins"][pin]["pin_mapped"] = module_setup[plugin_name]["pins"][pin]["pin"]
                    del module_setup[plugin_name]["pins"][pin]["pin"]

            mplugins.load_plugin(plugin_id, module_setup[plugin_name], self.config)

        self.modules[slot_name] = {
            "defaults": module_defaults,
            "setup": module_setup,
            "instances": mplugins.plugin_instances,
        }

        self.config_load()

    def del_plugin(self, plugin_instance, plugin_id, widget):
        self.config["plugins"].pop(plugin_id)
        self.config_load()
        # self.load_tree()
        # self.display()

    def select_plugin(self):

        def change(combo, info, description, selected):
            plugin_name = combo.currentText()
            plugin_list = self.plugins.list()
            plugins = riocore.Plugins()
            plugins.load_plugins({"plugins": [{"type": plugin_name}]})
            infotext = plugins.plugin_instances[0].INFO
            info.setText(infotext)
            descriptiontext = plugins.plugin_instances[0].DESCRIPTION
            description.clear()
            description.insertPlainText(descriptiontext)

        plugin_list = self.plugins.list()
        plugins = riocore.Plugins()
        plugins.load_plugins({"plugins": [{"type": plugin_list[0]["name"]}]})
        infotext = plugins.plugin_instances[0].INFO
        descriptiontext = plugins.plugin_instances[0].DESCRIPTION

        dialog = QDialog()
        dialog.setWindowTitle("add Plugin")
        dialog.setFixedWidth(500)
        dialog.setFixedHeight(400)

        dialog.buttonBox = QDialogButtonBox(QDialogButtonBox.Ok)
        dialog.buttonBox.accepted.connect(dialog.accept)

        dialog.layout = QVBoxLayout()

        hlayout = QHBoxLayout()

        vlayout_left = QVBoxLayout()

        message = QLabel("Plugin-Type:")
        vlayout_left.addWidget(message)
        combo = QComboBox(self)
        for plugin in plugin_list:
            combo.addItem(plugin["name"])
        vlayout_left.addWidget(combo)
        vlayout_left.addStretch()

        vlayout = QVBoxLayout()
        info = QLabel(infotext)
        vlayout.addWidget(info)

        description = QPlainTextEdit()
        description.clear()
        description.insertPlainText(descriptiontext)

        vlayout.addWidget(description)

        hlayout.addLayout(vlayout_left)
        hlayout.addLayout(vlayout)

        dialog.layout.addLayout(hlayout)

        cb = partial(change, combo, info, description)
        combo.activated.connect(cb)

        dialog.layout.addWidget(dialog.buttonBox)
        dialog.setLayout(dialog.layout)

        if dialog.exec():
            return combo.currentText()

    def select_module(self):
        dialog = QDialog()
        dialog.setWindowTitle("add Module")

        dialog.buttonBox = QDialogButtonBox(QDialogButtonBox.Ok)
        dialog.buttonBox.accepted.connect(dialog.accept)

        dialog.layout = QVBoxLayout()
        message = QLabel("Slot:")
        dialog.layout.addWidget(message)
        combo_slot = QComboBox(self)

        message = QLabel("Module:")
        dialog.layout.addWidget(message)
        combo_module = QComboBox(self)

        for slot in self.board.get("slots", []):
            slot_name = slot["name"]
            if slot_name not in self.modules:
                combo_slot.addItem(slot_name)
        dialog.layout.addWidget(combo_slot)

        for module in self.module_names:
            combo_module.addItem(module)
        dialog.layout.addWidget(combo_module)

        dialog.layout.addWidget(dialog.buttonBox)
        dialog.setLayout(dialog.layout)

        if dialog.exec():
            return (combo_slot.currentText(), combo_module.currentText())

    def generate(self):
        config = copy.deepcopy(self.config)
        # cleanup
        for module in config.get("modules", []):
            slot_name = module.get("slot")
            module_name = module.get("module")
            module_setup = module.get("setup")
            module_path = self.get_path(f"modules/{module_name}.json")
            moduleJsonStr = open(module_path, "r").read()
            module_defaults = json.loads(moduleJsonStr)
            for name, setup in module.get("setup", {}).items():
                for pin, pin_setup in setup.get("pins", {}).items():
                    del pin_setup["pin_mapped"]

        project = riocore.Project(json.dumps(config, indent=4))
        project.generator()

        config_name = self.config.get("name")

        for filename, widget in self.gateware.items():
            file_content = open(f"Output/{config_name}/Gateware/{filename}", "r").read()
            widget.clear()
            widget.insertPlainText(file_content)
            widget.verticalScrollBar().setValue(0)

        for filename, widget in self.linuxcnc.items():
            if filename == "rio.c":
                file_content = open(f"Output/{config_name}/LinuxCNC/Component/{filename}", "r").read()
            else:
                file_content = open(f"Output/{config_name}/LinuxCNC/Configuration/{filename}", "r").read()
            widget.clear()
            widget.insertPlainText(file_content)
            widget.verticalScrollBar().setValue(0)

    def save_config(self, widget):
        print("save...")
        config = copy.deepcopy(self.config)
        # cleanup
        for module in config.get("modules", []):
            slot_name = module.get("slot")
            module_name = module.get("module")
            module_setup = module.get("setup")
            module_path = self.get_path(f"modules/{module_name}.json")
            moduleJsonStr = open(module_path, "r").read()
            module_defaults = json.loads(moduleJsonStr)
            for name, setup in module.get("setup", {}).items():
                for pin, pin_setup in setup.get("pins", {}).items():
                    del pin_setup["pin_mapped"]

        file_dialog = QFileDialog(self)
        file_dialog.setNameFilters(["json (*.json)"])
        name = file_dialog.getSaveFileName(self, "Save File", self.config_file, "json (*.json)")
        if name[0]:
            open(name[0], "w").write(json.dumps(config, indent=4))

    def tree_add_plugin(self, parent, plugin_instance, nopins=False, expand=False):
        name = plugin_instance.plugin_setup.get("name")
        title = plugin_instance.NAME
        if name:
            title = f"{name} ({plugin_instance.NAME})"

        help_text = plugin_instance.INFO

        aitem = QStandardItem()
        parent.appendRow(
            [
                MyStandardItem(title, help_text=help_text),
                aitem,
            ]
        )
        button = QPushButton("delete")
        cb = partial(self.del_plugin, plugin_instance, plugin_instance.plugin_id)
        button.clicked.connect(cb)
        button.setMaximumSize(button.sizeHint())
        self.treeview.setIndexWidget(aitem.index(), button)

        plugin_view = parent.child(parent.rowCount() - 1)
        self.tree_add_options(plugin_view, plugin_instance, expand=expand)
        self.tree_add_pins(plugin_view, plugin_instance, expand=expand, nopins=nopins)
        if plugin_instance.TYPE == "joint":
            self.tree_add_joint(plugin_view, plugin_instance, expand=expand)
            if plugin_instance.SIGNALS and not plugin_instance.plugin_setup.get("is_joint", True):
                self.tree_add_signals(plugin_view, plugin_instance, expand=expand)
        else:
            if plugin_instance.SIGNALS:
                self.tree_add_signals(plugin_view, plugin_instance, expand=expand)
        if expand:
            self.treeview.expand(self.model.indexFromItem(plugin_view))

    def callback_plugin_name(self, parent, plugin_instance, value):
        parent.setText(f"{value} ({plugin_instance.NAME})")

    def tree_add_options(self, parent, plugin_instance, expand=False):
        for option_name, option_defaults in plugin_instance.OPTIONS.items():
            title = option_name.title()
            unit = option_defaults.get("unit")
            if unit:
                title = f"{title} ({unit})"
            help_text = option_defaults.get("description", title)
            aitem = QStandardItem()
            parent.appendRow(
                [
                    MyStandardItem(title, help_text=help_text),
                    aitem,
                ]
            )
            cb = partial(self.callback_plugin_name, parent, plugin_instance)
            self.treeview.setIndexWidget(aitem.index(), self.edit_item(plugin_instance.plugin_setup, option_name, option_defaults, cb=cb))

            options_view = parent.child(parent.rowCount() - 1)
            if expand:
                self.treeview.expand(self.model.indexFromItem(options_view))

    def tree_add_modifier(self, parent, pin_setup, modifier_id, modifier):
        mitem = QStandardItem()
        parent.appendRow(
            [
                MyStandardItem("Modifier"),
                mitem,
                MyStandardItem(""),
            ]
        )
        modifier_view = parent.child(parent.rowCount() - 1)
        self.treeview.setIndexWidget(mitem.index(), modifier_selector(self, pin_setup, modifier_id, modifier_view))

    def tree_add_signals(self, parent, plugin_instance, expand=False):
        signals_view = MyStandardItem("Signals", help_text="signal-configuration for this plugin instance")
        parent.appendRow(signals_view)
        if expand:
            self.treeview.expand(self.model.indexFromItem(signals_view))

        if "signals" not in plugin_instance.plugin_setup:
            plugin_instance.plugin_setup["signals"] = {}
        signals_setup = plugin_instance.plugin_setup["signals"]

        for signal_name, signal_defaults in plugin_instance.SIGNALS.items():
            if signal_name not in signals_setup:
                signals_setup[signal_name] = {}
            help_text = f"{signal_name} config"

            signal_view = MyStandardItem(signal_name, help_text="signal-configuration for this plugin instance")
            signals_view.appendRow(signal_view)
            if expand:
                self.treeview.expand(self.model.indexFromItem(signal_view))

            for option, option_setup in {"net": {"type": str}, "function": {"type": str}}.items():
                help_text = f"{option} config"
                citem = QStandardItem()
                signal_view.appendRow(
                    [
                        MyStandardItem(option, help_text=help_text),
                        citem,
                    ]
                )
                signal_option_view = signal_view.child(signal_view.rowCount() - 1)
                cb = None
                self.treeview.setIndexWidget(citem.index(), self.edit_item(signals_setup[signal_name], option, option_setup, cb=cb))
                if expand:
                    self.treeview.expand(self.model.indexFromItem(signal_option_view))


            display_view = MyStandardItem("Display", help_text="display-configuration for this signal")
            signal_view.appendRow(display_view)
            if expand:
                self.treeview.expand(self.model.indexFromItem(display_view))

            if signal_defaults["direction"] == "input" or signals_setup[signal_name].get("net"):
                if signal_defaults.get("bool"):
                    type_options = ["none", "led", "rectled"]
                else:
                    type_options = ["none", "number", "bar", "meter"]
            else:
                if signal_defaults.get("bool"):
                    type_options = ["none", "checkbutton", "button"]
                else:
                    type_options = ["none", "scale", "spinbox", "dial", "jogwheel"]

            if "display" not in signals_setup[signal_name]:
                signals_setup[signal_name]["display"] = {}

            for option, option_setup in {"title": {"type": str}, "section": {"type": str}, "type": {"type": "select", "options": type_options}}.items():
                help_text = f"{option} config"
                citem = QStandardItem()
                display_view.appendRow(
                    [
                        MyStandardItem(option, help_text=help_text),
                        citem,
                    ]
                )
                signal_option_view = display_view.child(display_view.rowCount() - 1)
                cb = None
                self.treeview.setIndexWidget(citem.index(), self.edit_item(signals_setup[signal_name]["display"], option, option_setup, cb=cb))
                if expand:
                    self.treeview.expand(self.model.indexFromItem(signal_option_view))


    def tree_add_joint(self, parent, plugin_instance, expand=False):
        joint_view = MyStandardItem("Joint", help_text="joint-configuration for this plugin instance")
        parent.appendRow(joint_view)
        if expand:
            self.treeview.expand(self.model.indexFromItem(joint_view))

        if "joint" not in plugin_instance.plugin_setup:
            plugin_instance.plugin_setup["joint"] = {}
        joints_setup = plugin_instance.plugin_setup["joint"]

        joint_options = {
            "scale": {
                "type": float,
            },
            "type": {
                "type": "select",
                "options": ["LINEAR", "ROTARY"],
            },
            "home": {
                "type": float,
            },
            "home_sequence": {
                "type": int,
            },
            "min_limit": {
                "type": float,
            },
            "max_limit": {
                "type": float,
            },
            "max_velocity": {
                "type": float,
            },
            "max_acceleration": {
                "type": float,
            },
            "stepgen_maxaccel": {
                "type": float,
            },
            "home_search_vel": {
                "type": float,
            },
            "home_latch_vel": {
                "type": float,
            },
            "home_final_vel": {
                "type": float,
            },
            "home_offset": {
                "type": float,
            },
            "home_ignore_limits": {
                "type": "select",
                "options": ["YES", "NO"],
            },
            "home_use_index": {
                "type": "select",
                "options": ["YES", "NO"],
            },

        }

        for option, option_setup in joint_options.items():
            help_text = f"{option} config"
            citem = QStandardItem()
            joint_view.appendRow(
                [
                    MyStandardItem(option, help_text=help_text),
                    citem,
                ]
            )
            joint_option_view = joint_view.child(joint_view.rowCount() - 1)
            # cb = partial(self.callback_plugin_name, parent, plugin_instance)
            cb = None
            self.treeview.setIndexWidget(citem.index(), self.edit_item(joints_setup, option, option_setup, cb=cb))
            if expand:
                self.treeview.expand(self.model.indexFromItem(joint_option_view))


    def tree_add_pins(self, parent, plugin_instance, expand=False, nopins=False):
        pins_view = MyStandardItem("Pins", help_text="pin-configuration for this plugin instance")
        parent.appendRow(pins_view)
        if expand:
            self.treeview.expand(self.model.indexFromItem(pins_view))
        for pin_name, pin_defaults in plugin_instance.PINDEFAULTS.items():
            pin_setup = plugin_instance.plugin_setup.get("pins", {}).get(pin_name, {})
            direction = pin_defaults["direction"]
            optional = pin_defaults.get("optional")
            help_text = f"pin location for {direction} pin: {pin_name}"
            if optional:
                help_text = f"{help_text} (optional)"
            pin_title = f"{pin_name} ({direction})"
            citem = QStandardItem()
            pins_view.appendRow(
                [
                    MyStandardItem(pin_title, help_text=help_text),
                    citem,
                ]
            )
            if not nopins:
                self.treeview.setIndexWidget(citem.index(), self.edit_item(pin_setup, "pin", {"type": "select", "options": self.pinlist}))

            pin_view = pins_view.child(pins_view.rowCount() - 1)
            if expand:
                self.treeview.expand(self.model.indexFromItem(pin_view))

            if direction == "input":
                pitem = QStandardItem()
                pin_view.appendRow(
                    [
                        MyStandardItem("Pullup", help_text="activate pullup resistor for this pin"),
                        pitem,
                    ]
                )
                self.treeview.setIndexWidget(pitem.index(), self.edit_item(pin_setup, "pullup", {"type": bool}))

            bitem = QStandardItem()
            pin_view.appendRow(
                [
                    MyStandardItem("Modifiers", help_text="pin modifier chain"),
                    bitem,
                ]
            )
            button = QPushButton("add")
            button.setMaximumSize(button.sizeHint())
            self.treeview.setIndexWidget(bitem.index(), button)
            modifiers_view = pin_view.child(pin_view.rowCount() - 1)
            button.clicked.connect(partial(self.add_modifier, modifiers_view, pin_setup))
            if expand:
                self.treeview.expand(self.model.indexFromItem(modifiers_view))

            for modifier_id, modifier in enumerate(pin_setup.get("modifier", [])):
                self.tree_add_modifier(modifiers_view, pin_setup, modifier_id, modifier)
            self.treeview.expand(self.model.indexFromItem(modifiers_view))


if __name__ == "__main__":
    app = QApplication(sys.argv)

    parser = argparse.ArgumentParser()
    parser.add_argument("config", help="config", nargs="?", type=str, default=None)
    args = parser.parse_args()

    form = WinForm(args)
    form.show()
    sys.exit(app.exec_())

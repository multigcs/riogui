#!/usr/bin/env python3
#
#

import argparse
import copy
import glob
import hashlib
import importlib
import json
import os
import re
import subprocess
import sys
import time
from functools import partial

import graphviz
import riocore
from riocore import halpins
from PyQt5 import QtGui, QtSvg
from PyQt5.QtCore import QRect, Qt, QTimer
from PyQt5.QtGui import QStandardItem, QStandardItemModel
from PyQt5.QtWidgets import (
    QApplication,
    QCheckBox,
    QComboBox,
    QDialog,
    QDialogButtonBox,
    QDoubleSpinBox,
    QFileDialog,
    QGridLayout,
    QHBoxLayout,
    QLabel,
    QLineEdit,
    QListWidget,
    QPlainTextEdit,
    QPushButton,
    QScrollArea,
    QSpinBox,
    QTableWidget,
    QTableWidgetItem,
    QTabWidget,
    QTreeView,
    QVBoxLayout,
    QWidget,
)

riocore_path = os.path.dirname(riocore.__file__)

STYLESHEET = """
    background-color: #444444;
    color: white;
"""
STYLESHEET_CHECKBOX = """
    QCheckBox::indicator::unchecked {
        background-color: lightgray;
    }
"""
STYLESHEET_BUTTON = """
    QPushButton::disabled {
        background-color: black;
    }
"""
STYLESHEET_CHECKBOX_GREEN_RED = """
    QCheckBox::indicator::checked {
        background-color: green;
    }
    QCheckBox::indicator::unchecked {
        background-color: red;
    }
"""


class MyQSvgWidget(QtSvg.QSvgWidget):
    def mousePressEvent(self, event):
        size = self.size()
        self.renderer().setViewBox(QRect(0, 0, size.width(), size.height()))
        self.repaint()

    def wheelEvent(self, event: QtGui.QWheelEvent) -> None:
        delta = event.angleDelta()
        mp_x = event.pos().x()
        mp_y = event.pos().y()
        if delta.y() < 0:
            scale = 1.1
            diff_x = -mp_x / 10
            diff_y = -mp_y / 10
        else:
            scale = 0.9
            diff_x = mp_x / 10
            diff_y = mp_y / 10
        viewbox = self.renderer().viewBox()
        x = int(viewbox.x()) + diff_x
        y = int(viewbox.y()) + diff_y
        width = int(viewbox.width()) * scale
        height = int(viewbox.height()) * scale
        self.renderer().setViewBox(QRect(int(x), int(y), int(width), int(height)))
        self.repaint()


class MyStandardItem(QStandardItem):
    def __init__(self, txt="", font_size=12, set_bold=False, key=None, help_text=None):
        super().__init__()
        self.key = key
        if help_text:
            self.setToolTip(help_text)
        else:
            self.setToolTip(txt)
        self.setEditable(False)
        self.setText(txt)


class edit_float(QDoubleSpinBox):
    def __init__(self, win, obj, key, vmin=None, vmax=None, cb=None, help_text=None, default=None):
        super().__init__()
        self.win = win
        self.cb = cb
        self.obj = obj
        self.key = key
        self.default = default
        if help_text:
            self.setToolTip(help_text)
        if vmin:
            self.setMinimum(vmin)
        else:
            self.setMinimum(-999999)
        if vmax:
            self.setMaximum(vmax)
        else:
            self.setMaximum(999999)
        if key in obj:
            self.setValue(float(obj[key]))
        elif default is not None:
            self.setValue(float(default))
        self.valueChanged.connect(self.change)
        self.editingFinished.connect(self.change)
        self.setFocusPolicy(Qt.StrongFocus)

    def wheelEvent(self, *args, **kwargs):
        if self.hasFocus():
            return QSpinBox.wheelEvent(self, *args, **kwargs)

    def change(self):
        if self.value() != self.default:
            self.obj[self.key] = self.value()
        elif self.key in self.obj:
            del self.obj[self.key]
        if self.cb:
            self.cb(self.value())
        else:
            self.win.display()


class edit_int(QSpinBox):
    def __init__(self, win, obj, key, vmin=None, vmax=None, cb=None, help_text=None, default=None):
        super().__init__()
        self.win = win
        self.cb = cb
        self.obj = obj
        self.key = key
        self.default = default
        if help_text:
            self.setToolTip(help_text)
        if vmin:
            self.setMinimum(vmin)
        else:
            self.setMinimum(-999999)
        if vmax:
            self.setMaximum(vmax)
        else:
            self.setMaximum(999999)
        if key in obj:
            self.setValue(int(obj[key]))
        elif default is not None:
            self.setValue(int(default))
        self.valueChanged.connect(self.change)
        self.editingFinished.connect(self.change)
        self.setFocusPolicy(Qt.StrongFocus)

    def wheelEvent(self, *args, **kwargs):
        if self.hasFocus():
            return QSpinBox.wheelEvent(self, *args, **kwargs)

    def change(self):
        if self.value() != self.default:
            self.obj[self.key] = self.value()
        elif self.key in self.obj:
            del self.obj[self.key]
        if self.cb:
            self.cb(self.value())
        else:
            self.win.display()


class edit_text(QLineEdit):
    def __init__(self, win, obj, key, cb=None, help_text=None, default=None):
        super().__init__()
        self.win = win
        self.cb = cb
        self.obj = obj
        self.key = key
        self.default = default
        if help_text:
            self.setToolTip(help_text)
        if key in obj:
            self.setText(str(obj[key]))
        elif default is not None:
            self.setText(str(default))
        self.textChanged.connect(self.change)

    def change(self):
        if self.text() != self.default:
            self.obj[self.key] = self.text()
        elif self.key in self.obj:
            del self.obj[self.key]
        if self.cb:
            self.cb(self.text())
        else:
            self.win.display()


class edit_bool(QCheckBox):
    def __init__(self, win, obj, key, cb=None, help_text=None, default=None):
        super().__init__()
        self.win = win
        self.cb = cb
        self.obj = obj
        self.key = key
        self.default = default
        self.setStyleSheet(STYLESHEET_CHECKBOX)
        if help_text:
            self.setToolTip(help_text)
        if key in obj:
            self.setChecked(obj[key])
        elif default is not None:
            self.setChecked(default)
        self.stateChanged.connect(self.change)

    def change(self):
        if self.isChecked() != self.default:
            self.obj[self.key] = self.isChecked()
        elif self.key in self.obj:
            del self.obj[self.key]
        if self.cb:
            self.cb(self.text())
        else:
            self.win.display()


class edit_combobox(QComboBox):
    def __init__(self, win, obj, key, options, cb=None, help_text=None, default=None):
        super().__init__()
        self.win = win
        self.cb = cb
        self.obj = obj
        self.key = key
        self.default = default
        options = options.copy()
        if help_text:
            self.setToolTip(help_text)
        if key in obj:
            if obj[key] not in options:
                options.append(obj[key])
        else:
            options.append("")
        for option in options:
            self.addItem(option)
        self.setEditable(True)
        if key in obj:
            self.setCurrentIndex(options.index(obj[key]))
        elif default is not None:
            self.setCurrentIndex(options.index(default))
        else:
            self.setCurrentIndex(options.index(""))
        self.editTextChanged.connect(self.change)
        self.setFocusPolicy(Qt.StrongFocus)

    def wheelEvent(self, *args, **kwargs):
        if self.hasFocus():
            return QComboBox.wheelEvent(self, *args, **kwargs)

    def change(self):
        if self.currentText() != self.default:
            self.obj[self.key] = self.currentText()
        elif self.key in self.obj:
            del self.obj[self.key]
        if self.cb:
            self.cb(self.currentText())
        else:
            self.win.display()


class modifier_selector(QComboBox):
    def __init__(self, win, pin_setup, modifier_id, modifier_view, help_text=None):
        super().__init__()
        self.win = win
        self.pin_setup = pin_setup
        self.modifier_id = modifier_id
        self.modifier_view = modifier_view
        self.entrys = list(set(riocore.plugins.Modifiers().pin_modifier_list()))
        self.entrys.append("--delete--")
        if help_text:
            self.setToolTip(help_text)
        for entry in self.entrys:
            self.addItem(entry)
        active = pin_setup["modifier"][self.modifier_id]["type"]
        self.setCurrentIndex(self.entrys.index(active))
        self.setEditable(False)
        self.activated.connect(self.change)
        self.setFocusPolicy(Qt.StrongFocus)

    def wheelEvent(self, *args, **kwargs):
        if self.hasFocus():
            return QComboBox.wheelEvent(self, *args, **kwargs)

    def change(self):
        selected = self.currentText()
        if selected == "--delete--":
            del self.pin_setup["modifier"][self.modifier_id]
            parent = self.modifier_view.parent()
            while parent.rowCount() > 0:
                parent.removeRow(0)
            for modifier_id, modifier in enumerate(self.pin_setup.get("modifier", [])):
                self.win.tree_add_modifier(parent, self.pin_setup, modifier_id, modifier)
        else:
            self.pin_setup["modifier"][self.modifier_id]["type"] = selected
        self.win.display()


class WinForm(QWidget):
    def __init__(self, args, parent=None):
        super(WinForm, self).__init__(parent)
        self.setWindowTitle("LinuxCNC-RIO - Setup-GUI")
        self.setMinimumWidth(1400)
        self.setMinimumHeight(900)
        self.setStyleSheet(STYLESHEET)

        self.listFile = QListWidget()
        layout = QGridLayout()
        self.setLayout(layout)

        self.treeview = QTreeView()
        # self.treeview.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.model = QStandardItemModel()
        self.model.setHorizontalHeaderLabels(["Name", "Value"])
        self.model.itemChanged.connect(self.itemChanged)
        self.treeview.setModel(self.model)
        self.treeview.setUniformRowHeights(True)

        if os.path.isfile(args.config):
            self.config_file = args.config
        elif os.path.isfile(f"{riocore_path}/configs/{args.config}"):
            self.config_file = f"{riocore_path}/configs/{args.config}"
        else:
            print(f"can not load: {args.config}")
            exit(1)
        print(f"loading: {self.config_file}")

        layout.addWidget(self.treeview, 0, 0)

        self.tabwidget = QTabWidget()
        layout.addWidget(self.tabwidget, 0, 1)
        self.gateware_hash = None

        self.compile_sub = None
        self.compile_start = 0
        self.flash_sub = None
        self.flash_start = 0

        self.pin_table = QTableWidget()
        self.pin_table.setColumnCount(6)
        self.pin_table.setHorizontalHeaderItem(0, QTableWidgetItem("Pin"))
        self.pin_table.setHorizontalHeaderItem(1, QTableWidgetItem("Plugin"))
        self.pin_table.setHorizontalHeaderItem(2, QTableWidgetItem("Pin-Name"))
        self.pin_table.setHorizontalHeaderItem(3, QTableWidgetItem("Mapping"))
        self.pin_table.setHorizontalHeaderItem(4, QTableWidgetItem("Direction"))
        self.pin_table.setHorizontalHeaderItem(5, QTableWidgetItem("Comment"))
        self.pin_table.horizontalHeader().sectionClicked.connect(self.onHeaderClickedPins)
        self.pin_table_sort_col = 1

        self.sig_table = QTableWidget()
        self.sig_table.setColumnCount(5)
        self.sig_table.setHorizontalHeaderItem(0, QTableWidgetItem("Halname"))
        self.sig_table.setHorizontalHeaderItem(1, QTableWidgetItem("Dir"))
        self.sig_table.setHorizontalHeaderItem(2, QTableWidgetItem("Target"))
        self.sig_table.setHorizontalHeaderItem(3, QTableWidgetItem("Type"))
        self.sig_table.setHorizontalHeaderItem(4, QTableWidgetItem("Comment"))
        self.sig_table.horizontalHeader().sectionClicked.connect(self.onHeaderClickedSignals)
        self.sig_table_sort_col = 1

        self.imagew = MyQSvgWidget()

        scroll = QScrollArea()
        scroll.setWidget(self.imagew)
        scroll.setWidgetResizable(True)
        self.tabwidget.addTab(scroll, "Flow")
        self.tabwidget.addTab(self.pin_table, "Pins")
        self.tabwidget.addTab(self.sig_table, "Signals")

        self.jsonpreview = QPlainTextEdit()
        self.jsonpreview.clear()
        self.jsonpreview.insertPlainText("...")
        # self.jsonpreview.verticalScrollBar().setValue(0)
        self.tabwidget.addTab(self.jsonpreview, "Json-Preview")

        self.gateware_tabwidget = QTabWidget()
        self.tabwidget.addTab(self.gateware_tabwidget, "Gateware")

        self.linuxcnc_tabwidget = QTabWidget()
        self.tabwidget.addTab(self.linuxcnc_tabwidget, "LinuxCNC")

        self.gateware = {
            "rio.v": QPlainTextEdit(),
            "Makefile": QPlainTextEdit(),
            "Compile-Output": QPlainTextEdit(),
            "Flash-Output": QPlainTextEdit(),
        }
        self.linuxcnc = {
            "rio.ini": QPlainTextEdit(),
            "rio.hal": QPlainTextEdit(),
            "custom_postgui.hal": QPlainTextEdit(),
            "rio-gui.xml": QPlainTextEdit(),
            "rio.c": QPlainTextEdit(),
        }

        for filename, widget in self.gateware.items():
            widget.clear()
            widget.insertPlainText("")
            self.gateware_tabwidget.addTab(widget, filename)
        for filename, widget in self.linuxcnc.items():
            widget.clear()
            widget.insertPlainText("")
            self.linuxcnc_tabwidget.addTab(widget, filename)

        container = QWidget()
        button_layout = QHBoxLayout(container)
        layout.addWidget(container, 1, 1)

        self.info_widget = QLabel("loading...")
        layout.addWidget(self.info_widget, 1, 0)

        info_container = QWidget()
        info_layout = QHBoxLayout(info_container)
        layout.addWidget(info_container, 2, 1)

        self.info_saved = QCheckBox("Saved")
        self.info_saved.setStyleSheet(STYLESHEET_CHECKBOX_GREEN_RED)
        info_layout.addWidget(self.info_saved)
        self.info_saved.setChecked(True)

        self.info_generated = QCheckBox("Generated")
        self.info_generated.setStyleSheet(STYLESHEET_CHECKBOX_GREEN_RED)
        info_layout.addWidget(self.info_generated)
        self.info_generated.setChecked(False)

        self.info_compiled = QCheckBox("Compiled")
        self.info_compiled.setStyleSheet(STYLESHEET_CHECKBOX_GREEN_RED)
        info_layout.addWidget(self.info_compiled)
        self.info_compiled.setChecked(False)

        self.info_flashed = QCheckBox("Flashed")
        self.info_flashed.setStyleSheet(STYLESHEET_CHECKBOX_GREEN_RED)
        info_layout.addWidget(self.info_flashed)
        self.info_flashed.setChecked(False)

        info_layout.addStretch()

        self.button_save = QPushButton("Save")
        self.button_save.clicked.connect(self.save_config_cb)
        self.button_save.setStyleSheet(STYLESHEET_BUTTON)
        button_layout.addWidget(self.button_save)

        self.button_save_as = QPushButton("Save as")
        self.button_save_as.clicked.connect(self.save_config_as)
        self.button_save_as.setStyleSheet(STYLESHEET_BUTTON)
        button_layout.addWidget(self.button_save_as)

        self.button_generate = QPushButton("Generate")
        self.button_generate.clicked.connect(self.generate_cb)
        self.button_generate.setStyleSheet(STYLESHEET_BUTTON)
        button_layout.addWidget(self.button_generate)

        self.button_compile = QPushButton("Compile")
        self.button_compile.clicked.connect(self.compile_cb)
        self.button_compile.setStyleSheet(STYLESHEET_BUTTON)
        button_layout.addWidget(self.button_compile)

        self.button_flash = QPushButton("Flash")
        self.button_flash.clicked.connect(self.flash_cb)
        self.button_flash.setStyleSheet(STYLESHEET_BUTTON)
        button_layout.addWidget(self.button_flash)

        button = QPushButton("reload tree")
        button.clicked.connect(self.load_tree)
        button_layout.addWidget(button)

        button = QPushButton("reload config")
        button.clicked.connect(self.config_load)
        button_layout.addWidget(button)

        button = QPushButton("test-gui")
        button.clicked.connect(self.testgui)
        button_layout.addWidget(button)

        self.json_load()
        self.config_load()
        # self.load_tree()
        # self.display()
        self.config_original = self.clean_config(self.config)
        self.config_checked = {}

        self.request_load_tree = 0
        self.request_pin_table_load = 0
        self.request_sig_table_load = 0
        self.timer = QTimer()
        self.timer.timeout.connect(self.runTimer)
        self.timer.start(1000)

    def check_status(self):
        self.config_checked = self.clean_config(self.config)
        config_name = self.config.get("name")
        self.button_save.setEnabled(True)
        self.button_save_as.setEnabled(True)

        if self.config_original != self.clean_config(self.config):
            self.info_saved.setChecked(False)
            self.info_generated.setChecked(False)
            self.button_generate.setEnabled(False)
            self.button_compile.setEnabled(False)
            self.button_flash.setEnabled(False)
        else:
            self.info_saved.setChecked(True)
            self.button_generate.setEnabled(True)

            # checking generated config
            ret = os.system(f"diff {self.config_file} Output/{config_name}/.config.json >/dev/null")
            if ret == 0:
                self.info_generated.setChecked(True)
                self.button_compile.setEnabled(True)
            else:
                self.info_generated.setChecked(False)
                self.button_compile.setEnabled(False)

        # checking gateware
        hash_compiled = ""
        hash_compiled_file = f"Output/{config_name}/Gateware/hash_compiled.txt"
        if os.path.isfile(hash_compiled_file):
            hash_compiled = open(hash_compiled_file, "r").read()
        if hash_compiled == self.gateware_hash:
            self.info_compiled.setChecked(True)
            self.button_flash.setEnabled(True)
        else:
            self.info_compiled.setChecked(False)
            self.button_flash.setEnabled(False)

        hash_flashed = ""
        hash_flashed_file = f"Output/{config_name}/Gateware/hash_flashed.txt"
        if os.path.isfile(hash_flashed_file):
            hash_flashed = open(hash_flashed_file, "r").read()
        if hash_flashed == self.gateware_hash:
            self.info_flashed.setChecked(True)
        else:
            self.info_flashed.setChecked(False)

    def runTimer(self):
        if self.request_load_tree > 1:
            self.request_load_tree -= 1
        elif self.request_load_tree == 1:
            self.load_tree()
            self.request_load_tree = 0

        if self.request_pin_table_load > 1:
            self.request_pin_table_load -= 1
        elif self.request_pin_table_load == 1:
            self.pin_table_load()
            self.request_pin_table_load = 0

        if self.request_sig_table_load > 1:
            self.request_sig_table_load -= 1
        elif self.request_sig_table_load == 1:
            self.sig_table_load()
            self.request_sig_table_load = 0

        if self.config_checked != self.clean_config(self.config):
            self.check_status()

        if self.compile_sub is not None:
            widget = self.gateware["Compile-Output"]
            config_name = self.config.get("name")
            logdata = open(f"Output/{config_name}/Gateware/compile.log", "r").read()
            widget.clear()
            duration = time.time() - self.compile_start

            if self.compile_sub.poll() is not None:
                widget.insertPlainText(logdata)
                self.compile_sub = None
                self.check_status()
                self.info_widget.setText(f"compile...done in {duration:0.1f}s")
            else:
                widget.insertPlainText(logdata)
                self.button_save.setEnabled(False)
                self.button_save_as.setEnabled(False)
                self.button_generate.setEnabled(False)
                self.button_compile.setEnabled(False)
                self.button_flash.setEnabled(False)
                self.info_widget.setText(f"compile...({duration:0.1f}s)")

        if self.flash_sub is not None:
            widget = self.gateware["Flash-Output"]
            config_name = self.config.get("name")
            logdata = open(f"Output/{config_name}/Gateware/flash.log", "r").read()
            widget.clear()
            duration = time.time() - self.flash_start

            if self.flash_sub.poll() is not None:
                widget.insertPlainText(logdata)
                self.flash_sub = None
                self.check_status()
                self.info_widget.setText(f"flash...done in {duration:0.1f}s")
            else:
                widget.insertPlainText(logdata)
                self.button_save.setEnabled(False)
                self.button_save_as.setEnabled(False)
                self.button_generate.setEnabled(False)
                self.button_flash.setEnabled(False)
                self.button_flash.setEnabled(False)
                self.info_widget.setText(f"flash...({duration:0.1f}s)")

    def onHeaderClickedPins(self, logicalIndex):
        logicalIndex += 1
        if self.pin_table_sort_col == logicalIndex:
            self.pin_table_sort_col = -logicalIndex
        else:
            self.pin_table_sort_col = logicalIndex
        self.pin_table_load()

    def onHeaderClickedSignals(self, logicalIndex):
        logicalIndex += 1
        if self.sig_table_sort_col == logicalIndex:
            self.sig_table_sort_col = -logicalIndex
        else:
            self.sig_table_sort_col = logicalIndex
        self.sig_table_load()

    def itemChanged(self, item):
        pass

    def json_load(self):
        # loading json config
        configJsonStr = open(self.config_file, "r").read()
        self.config = json.loads(configJsonStr)

    def closeEvent(self, event):
        if self.config_original != self.clean_config(self.config):
            self.save_config_as()

    def setup_merge(self, setup, defaults):
        for key, value in defaults.items():
            if key not in setup:
                setup[key] = copy.deepcopy(value)
            elif isinstance(value, dict):
                self.setup_merge(setup[key], value)

    def get_path(self, path):
        if os.path.exists(path):
            return path
        elif os.path.exists(f"{riocore_path}/{path}"):
            return f"{riocore_path}/{path}"
        print(f"can not find path: {path}")
        exit(1)

    def testgui(self):
        print("starting testgui..", f"{os.path.dirname(__file__)}/rio-test")
        filename = f"{self.config_file}.test-gui-temp.json"
        self.save_config(filename)
        testgui_path = f"{os.path.dirname(__file__)}/rio-test"
        os.system(f"({testgui_path} {filename} ; rm {filename}) &")

    def config_load(self):
        self.info_widget.setText(self.config_file)

        # loading board config
        boardcfg = self.config.get("boardcfg")
        if boardcfg:
            board_file = self.get_path(f"boards/{boardcfg}.json")
            self.board = {}
            boardJsonStr = open(board_file, "r").read()
            self.board = json.loads(boardJsonStr)

        slot_pinmapping = {}
        for slot in self.board.get("slots", []):
            slot_name = slot["name"]
            for pin_id, pin in slot["pins"].items():
                pin_name = f"{slot_name}:{pin_id}"
                slot_pinmapping[pin] = pin_name

        # loading slot/module configs
        self.modules = {}
        for module in self.config.get("modules", []):
            slot_name = module.get("slot")
            module_name = module.get("module")
            module_setup = module.get("setup", {})
            module_path = self.get_path(f"modules/{module_name}.json")
            moduleJsonStr = open(module_path, "r").read()
            module_defaults = json.loads(moduleJsonStr)

            mplugins = riocore.Plugins()
            for plugin_id, plugin_config in enumerate(module_defaults.get("plugins", [])):
                plugin_name = plugin_config.get("name")
                if plugin_name not in module_setup:
                    module_setup[plugin_name] = {}
                self.setup_merge(module_setup[plugin_name], plugin_config)
                if "pins" in module_setup[plugin_name]:
                    for pin in module_setup[plugin_name]["pins"]:
                        if "pin" in module_setup[plugin_name]["pins"][pin]:
                            module_setup[plugin_name]["pins"][pin]["pin_mapped"] = module_setup[plugin_name]["pins"][pin]["pin"]
                            del module_setup[plugin_name]["pins"][pin]["pin"]

                mplugins.load_plugin(plugin_id, module_setup[plugin_name], self.config)

            self.modules[slot_name] = {
                "defaults": module_defaults,
                "setup": module_setup,
                "instances": mplugins.plugin_instances,
            }

        # loading plugins
        self.plugins = riocore.Plugins()
        for plugin_id, plugin_config in enumerate(self.config.get("plugins", [])):
            self.plugins.load_plugin(plugin_id, plugin_config, self.config)

        self.items = {}
        self.pinlist = []
        self.pinmapping = {}
        self.pinmapping_rev = {}
        self.expansion_pins = []
        for plugin_instance in self.plugins.plugin_instances:
            if plugin_instance.TYPE == "expansion":
                for pin in plugin_instance.expansion_outputs():
                    self.expansion_pins.append(pin)
                    if pin not in self.pinlist:
                        self.pinlist.append(pin)
                for pin in plugin_instance.expansion_inputs():
                    self.expansion_pins.append(pin)
                    if pin not in self.pinlist:
                        self.pinlist.append(pin)

            for pin_name, pin_defaults in plugin_instance.PINDEFAULTS.items():
                if "pins" not in plugin_instance.plugin_setup:
                    continue
                if pin_name not in plugin_instance.plugin_setup["pins"]:
                    plugin_instance.plugin_setup["pins"][pin_name] = {}
                pin_setup = plugin_instance.plugin_setup["pins"][pin_name]
                if not pin_setup and pin_defaults.get("optional") is True:
                    continue
                pin = pin_setup["pin"]
                if pin not in self.pinlist:
                    self.pinlist.append(pin)
        for slot in self.board.get("slots", []):
            slot_name = slot.get("name")
            slot_pins = slot.get("pins", {})
            for pin_name, pin in slot_pins.items():
                pin_id = f"{slot_name}:{pin_name}"
                if pin not in self.pinlist:
                    self.pinlist.append(pin)
                self.pinmapping[pin_id] = pin
                self.pinmapping_rev[pin] = pin_id
                if pin_id not in self.pinlist:
                    self.pinlist.append(pin_id)

        def sort_key(value):
            numbers = re.findall(r"\d+", value)
            for number in numbers:
                value = value.replace(number, f"{int(number):09d}")
            return value

        def load_pins(board):
            # try to load list of pins from chipdb files
            family = board.get("family")
            fpga_type = board.get("type")
            package = board.get("package")
            check_name = family.lower().replace(" ", "_")
            check_path = f"riocore/chipdata/{check_name}.json"
            if os.path.isfile(check_path):
                chipJsonStr = open(check_path, "r").read()
                chipData = json.loads(chipJsonStr)
                for fpga_id in [fpga_type, fpga_type.replace("up", "")]:
                    if fpga_id in chipData:
                        if package in chipData[fpga_id]:
                            for pin_name in chipData[fpga_id][package]:
                                if pin_name not in self.pinlist:
                                    self.pinlist.append(pin_name)
                        break

        load_pins(self.board)
        self.pinlist.sort(key=sort_key)

        boards_path = self.get_path("boards/")
        modules_path = self.get_path("modules/")

        self.interfaces = []
        for path in glob.glob(f"{riocore_path}/interfaces/*"):
            self.interfaces.append(path.split("/")[-1])
        self.boards = []
        for path in glob.glob(f"{boards_path}/*.json"):
            self.boards.append(path.split("/")[-1].split(".")[0])
        self.module_names = []
        for path in glob.glob(f"{modules_path}/*.json"):
            self.module_names.append(path.split("/")[-1].split(".")[0])
        self.slots = []
        for slot in self.board.get("slots", []):
            slot_name = slot.get("name")
            if slot_name:
                self.slots.append(slot_name)

        self.load_tree()
        self.pin_table_load()
        self.sig_table_load()
        self.display()

    def display(self):
        try:
            self.generate_cb(preview=True)
            self.request_pin_table_load = 2
            self.request_sig_table_load = 2
            self.overview_load()
            self.json_preview()
            self.info_widget.setText(self.config_file)
        except Exception as error:
            print(f"ERROR: {error}")
            self.info_widget.setText(f"ERROR: {error}")

    def struct_clean(self, data):
        # removing empty lists and dicts
        for key in list(data):
            if isinstance(data[key], list):
                for pn, part in enumerate(data[key]):
                    if isinstance(part, dict):
                        if not part:
                            print("DEL1", key, pn, data[key][pn])
                            del data[key][pn]
                        else:
                            self.struct_clean(data[key][pn])
                if not data[key]:
                    del data[key]
            elif isinstance(data[key], dict):
                self.struct_clean(data[key])
                if not data[key]:
                    del data[key]
            elif data[key] is None:
                del data[key]

    def clean_config(self, config_unclean):
        config = copy.deepcopy(config_unclean)
        # cleanup
        for module in config.get("modules", []):
            for name, setup in module.get("setup", {}).items():
                for pin, pin_setup in setup.get("pins", {}).items():
                    if "pin_mapped" in pin_setup:
                        del pin_setup["pin_mapped"]
        for plugin in config.get("plugins", []):
            for name, plugin_config in plugin.get("config", {}).items():
                if "instance" in plugin_config:
                    del plugin_config["instance"]
        self.struct_clean(config)
        return config

    def json_preview(self):
        config = self.clean_config(self.config)
        self.jsonpreview.clear()
        self.jsonpreview.insertPlainText(json.dumps(config, indent=4))
        # self.jsonpreview.verticalScrollBar().setValue(0)

    def overview_load(self):
        num = 0
        fpga_name = f"{self.config.get('boardcfg')}"

        gAll = graphviz.Digraph("G", format="svg")
        gAll.attr(rankdir="LR")
        gAll.attr(bgcolor="black")

        sportsr = []
        sportsl = []

        # show slots
        for slot in self.board.get("slots", []):
            slot_name = slot.get("name")
            slot_pins = slot.get("pins", {})
            mportsl = []
            mportsr = []
            for pin_name, pin in slot_pins.items():
                pin_id = f"{slot_name}_{pin_name}"
                mportsl.append(f"<{pin}>{pin}")
                mportsr.append(f"<{pin_id}>{pin_name}")

            label = f"{{ {{{' | '.join(mportsl)}}} | {slot_name} | {{{' | '.join(mportsr)}}} }}"
            sportsr.append(label)

        for plugin_instance in self.plugins.plugin_instances:
            pports = []
            name = plugin_instance.plugin_setup.get("name", plugin_instance.title)
            title = plugin_instance.NAME
            if name:
                title = f"{name} ({plugin_instance.NAME})"

            if plugin_instance.TYPE == "expansion":
                title = plugin_instance.expansion_prefix

            for pin_name, pin_defaults in plugin_instance.PINDEFAULTS.items():
                pin_setup = plugin_instance.plugin_setup.get("pins", {}).get(pin_name, {})
                pports.append(f"<{pin_name}>{pin_name}")
                if not pin_setup and pin_defaults.get("optional") is True:
                    continue
                pin = pin_setup["pin"]

                con_dev = fpga_name
                con_pin = pin

                if pin and pin in self.expansion_pins:
                    con_dev = "_".join(pin.split("_")[0:-1])
                    con_pin = pin.replace("[", "").replace("]", "")

                if ":" in con_pin:
                    con_pin = con_pin.replace(":", "_")

                if pin_defaults["direction"] == "input":
                    modifiers = pin_setup.get("modifier", [])
                    if modifiers:
                        modifiers = reversed(modifiers)
                    color = "green"
                    arrow_dir = "back"
                else:
                    modifiers = pin_setup.get("modifier", [])
                    color = "red"
                    arrow_dir = "forward"

                if modifiers:
                    modifier_chain = []
                    for modifier_num, modifier in enumerate(modifiers):
                        modifier_type = modifier["type"]
                        modifier_chain.append(modifier_type)
                    modifier_label = f"{{ <l> | {' | '.join(modifier_chain)} | <r> }}"
                    gAll.edge(f"{con_dev}:{con_pin}", f"{name}_{pin_name}_{modifier_type}_{modifier_num}:l", dir=arrow_dir, color=color)
                    con_dev = f"{name}_{pin_name}_{modifier_type}_{modifier_num}"
                    con_pin = "r"
                    gAll.node(
                        f"{name}_{pin_name}_{modifier_type}_{modifier_num}",
                        shape="record",
                        label=modifier_label,
                        fontsize="11pt",
                        style="rounded, filled",
                        fillcolor="lightyellow",
                    )

                gAll.edge(f"{con_dev}:{con_pin}", f"{title}:{pin_name}", dir=arrow_dir, color=color)

                if pin and ":" not in pin and pin not in self.expansion_pins:
                    sportsr.append(f"<{pin}>{pin}")

                num += 1

            signalports = []
            for signal_name, signal_config in plugin_instance.plugin_setup.get("signals", {}).items():
                net = signal_config.get("net")
                function = signal_config.get("function")
                signalports.append(f"<signal_{signal_name}>{signal_name}")
                signal_direction = plugin_instance.SIGNALS.get(signal_name, {}).get("direction")
                direction_mapping = {"input": "normal", "output": "back", "inout": "both"}
                if function:
                    gAll.edge(f"{title}:signal_{signal_name}", f"{function}", dir=direction_mapping.get(signal_direction, "none"), color="white", fontcolor="white")
                    gAll.node(
                        function,
                        shape="record",
                        label=function,
                        fontsize="11pt",
                        style="rounded, filled",
                        fillcolor="lightpink",
                    )
                if net:
                    gAll.edge(f"{title}:signal_{signal_name}", f"{net}", dir=direction_mapping.get(signal_direction, "none"), color="white", fontcolor="white")
                    gAll.node(
                        net,
                        shape="record",
                        label=net,
                        fontsize="11pt",
                        style="rounded, filled",
                        fillcolor="lightpink",
                    )

            if plugin_instance.TYPE == "expansion":
                eports = []
                for pname in plugin_instance.expansion_outputs():
                    eports.append(f"<{pname.replace('[', '').replace(']', '')}>{pname}")
                for pname in plugin_instance.expansion_inputs():
                    eports.append(f"<{pname.replace('[', '').replace(']', '')}>{pname}")

                label = f"{{ {{{' | '.join(pports)}}} | {title} | {{{' | '.join(eports)}}} }}"

            elif signalports:
                label = f"{{ {{{' | '.join(pports)}}} | {title} | {{{' | '.join(signalports)}}} }}"
            else:
                label = f"{{ {{{' | '.join(pports)}}} | {title} }}"

            gAll.node(
                title,
                shape="record",
                label=label,
                fontsize="11pt",
                style="rounded, filled",
                fillcolor="lightblue",
            )

        for module_data in self.config.get("modules", []):
            slot_name = module_data.get("slot")
            module_name = module_data.get("module")
            title = slot_name
            if module_name:
                title = f"{module_name} ({title})"

            for plugin_instance in self.modules[slot_name]["instances"]:
                pports = []
                name = plugin_instance.plugin_setup.get("name")
                title = plugin_instance.NAME
                if name:
                    title = f"{name} ({plugin_instance.NAME})"
                for pin_name, pin_defaults in plugin_instance.PINDEFAULTS.items():
                    pin_setup = plugin_instance.plugin_setup.get("pins", {}).get(pin_name, {})
                    if "pin_mapped" not in pin_setup:
                        continue

                    pin = f"{slot_name}_{pin_setup['pin_mapped']}"
                    con_dev = fpga_name
                    con_pin = pin

                    if pin and pin in self.expansion_pins:
                        con_dev = "_".join(pin.split("_")[0:-1])
                        con_pin = pin.replace("[", "").replace("]", "")

                    if pin_defaults["direction"] == "input":
                        modifiers = pin_setup.get("modifier", [])
                        if modifiers:
                            modifiers = reversed(modifiers)
                        color = "green"
                        arrow_dir = "back"
                    else:
                        modifiers = pin_setup.get("modifier", [])
                        color = "red"
                        arrow_dir = "forward"

                    if modifiers:
                        modifier_chain = []
                        for modifier_num, modifier in enumerate(modifiers):
                            modifier_type = modifier["type"]
                            modifier_chain.append(modifier_type)
                        modifier_label = f"{{ <l> | {' | '.join(modifier_chain)} | <r> }}"
                        gAll.edge(f"{con_dev}:{con_pin}", f"{name}_{pin_name}_{modifier_type}_{modifier_num}:l", dir=arrow_dir, color=color)
                        con_dev = f"{name}_{pin_name}_{modifier_type}_{modifier_num}"
                        con_pin = "r"
                        gAll.node(
                            f"{name}_{pin_name}_{modifier_type}_{modifier_num}",
                            shape="record",
                            label=modifier_label,
                            fontsize="11pt",
                            style="rounded, filled",
                            fillcolor="lightyellow",
                        )

                    gAll.edge(f"{con_dev}:{con_pin}", f"{title}:{pin_name}", dir=arrow_dir, color=color)
                    pports.append(f"<{pin_name}>{pin_name}")

                net = plugin_instance.plugin_setup.get("net")
                if net:
                    gAll.edge(f"{title}", f"{net}", dir="none", color="white", fontcolor="white")
                    gAll.node(
                        net,
                        shape="record",
                        label=net,
                        fontsize="11pt",
                        style="rounded, filled",
                        fillcolor="lightpink",
                    )

                signalports = []
                for signal_name, signal_config in plugin_instance.plugin_setup.get("signals", {}).items():
                    net = signal_config.get("net")
                    function = signal_config.get("function")
                    signalports.append(f"<signal_{signal_name}>{signal_name}")
                    signal_direction = plugin_instance.SIGNALS.get(signal_name, {}).get("direction")
                    direction_mapping = {"input": "forward", "output": "back", "inout": "both"}
                    if function:
                        gAll.edge(f"{title}:signal_{signal_name}", f"{function}", dir=direction_mapping.get(signal_direction, "none"), color="white", fontcolor="white")
                        gAll.node(
                            function,
                            shape="record",
                            label=function,
                            fontsize="11pt",
                            style="rounded, filled",
                            fillcolor="lightpink",
                        )
                    if net:
                        gAll.edge(f"{title}:signal_{signal_name}", f"{net}", dir=direction_mapping.get(signal_direction, "none"), color="white", fontcolor="white")
                        gAll.node(
                            net,
                            shape="record",
                            label=net,
                            fontsize="11pt",
                            style="rounded, filled",
                            fillcolor="lightpink",
                        )

                if signalports:
                    label = f"{{ {{{' | '.join(pports)}}} | {title} | {{{' | '.join(signalports)}}} }}"
                else:
                    label = f"{{ {{{' | '.join(pports)}}} | {title} }}"
                gAll.node(
                    title,
                    shape="record",
                    label=label,
                    fontsize="11pt",
                    style="rounded, filled",
                    fillcolor="lightblue",
                )

        label = f"{{ {{{' | '.join(sportsl)}}} | {fpga_name} | {{{' | '.join(sportsr)}}} }}"
        gAll.node(f"{fpga_name}", shape="record", label=label, fontsize="11pt", style="rounded, filled", fillcolor="yellow")

        self.imagew.load(gAll.pipe().decode().encode())

        # self.imagew.setFixedSize(QSize(800, 600))
        # self.imagew.setFixedSize(self.imagew.renderer().defaultSize())

    def sig_edit_cb(self, widget):
        self.generate_cb(preview=True)
        self.request_load_tree = 3
        self.overview_load()
        self.json_preview()

    def sig_table_load(self):
        self.sig_table.setRowCount(0)
        table_data = []

        def sort_key(a):
            col = a[idx]
            numbers = re.findall(r"\d+", col)
            for number in numbers:
                col = col.replace(number, f"{int(number):09d}")
            return col.lower()

        options = []

        for module_data in self.config.get("modules", []):
            slot_name = module_data.get("slot")
            for plugin_instance in self.modules[slot_name]["instances"]:
                plugin_name = plugin_instance.plugin_setup.get("name", plugin_instance.title)
                plugin_title = plugin_instance.NAME
                if plugin_name:
                    plugin_title = f"{plugin_name} ({plugin_instance.NAME})"

                if plugin_instance.TYPE == "expansion":
                    title = plugin_instance.expansion_prefix

                for signal_name, signal_config in plugin_instance.signals().items():
                    signal_setup = signal_config.get("setup", {})
                    signal_direction = signal_config["direction"]
                    signal_halname = signal_config["halname"]
                    is_bool = signal_config.get("bool", False)
                    htype = "bit" if is_bool else "float"

                    if "userconfig" not in signal_config:
                        signal_config["userconfig"] = {}
                    userconfig = signal_config["userconfig"]
                    signal_net = userconfig.get("net", "")
                    signal_function = userconfig.get("function", "")
                    signal_setp = str(userconfig.get("setp", ""))

                    key = "net"
                    if signal_function:
                        key = "function"
                    elif signal_setp:
                        key = "setp"

                    if key == "function":
                        widget = self.edit_item(userconfig, "function", {"type": str, "default": ""}, cb=self.sig_edit_cb)
                    elif key == "setp":
                        widget = self.edit_item(userconfig, "setp", {"type": str, "default": ""}, cb=self.sig_edit_cb)
                    else:
                        widget = self.edit_item(userconfig, "net", {"type": "select", "options": options, "default": ""}, cb=self.sig_edit_cb)

                    options = []
                    for halpin, halpin_info in halpins.LINUXCNC_SIGNALS[signal_direction].items():
                        if is_bool:
                            if halpin_info.get("type") == bool:
                                options.append(halpin)
                        elif halpin_info.get("type") != bool:
                            options.append(halpin)

                    table_data.append(
                        (f"rio.{signal_halname}", {"output": "<-", "input": "->", "inout": "<->"}.get(signal_direction, signal_direction), signal_net, htype, key, plugin_instance, signal_name, widget)
                    )

        for plugin_instance in self.plugins.plugin_instances:
            plugin_name = plugin_instance.plugin_setup.get("name", plugin_instance.title)
            plugin_title = plugin_instance.NAME
            if plugin_name:
                plugin_title = f"{plugin_name} ({plugin_instance.NAME})"

            if plugin_instance.TYPE == "expansion":
                title = plugin_instance.expansion_prefix

            for signal_name, signal_config in plugin_instance.signals().items():
                signal_setup = signal_config.get("setup", {})
                signal_direction = signal_config["direction"]
                signal_halname = signal_config["halname"]
                is_bool = signal_config.get("bool", False)
                htype = "bit" if is_bool else "float"

                if "userconfig" not in signal_config:
                    signal_config["userconfig"] = {}
                userconfig = signal_config["userconfig"]
                signal_net = userconfig.get("net", "")
                signal_function = userconfig.get("function", "")
                signal_setp = str(userconfig.get("setp", ""))

                key = "net"
                if signal_function:
                    key = "function"
                elif signal_setp:
                    key = "setp"

                if key == "function":
                    widget = self.edit_item(userconfig, "function", {"type": str, "default": ""}, cb=self.sig_edit_cb)
                elif key == "setp":
                    widget = self.edit_item(userconfig, "setp", {"type": str, "default": ""}, cb=self.sig_edit_cb)
                else:
                    widget = self.edit_item(userconfig, "net", {"type": "select", "options": options, "default": ""}, cb=self.sig_edit_cb)

                options = []
                for halpin, halpin_info in halpins.LINUXCNC_SIGNALS[signal_direction].items():
                    if is_bool:
                        if halpin_info.get("type") == bool:
                            options.append(halpin)
                    elif halpin_info.get("type") != bool:
                        options.append(halpin)

                table_data.append(
                    (f"rio.{signal_halname}", {"output": "<-", "input": "->", "inout": "<->"}.get(signal_direction, signal_direction), signal_net, htype, key, plugin_instance, signal_name, widget)
                )

        if self.sig_table_sort_col > 0:
            idx = self.sig_table_sort_col - 1
            table_data.sort(key=sort_key)
        elif self.sig_table_sort_col < 0:
            idx = -self.sig_table_sort_col - 1
            table_data.sort(key=sort_key, reverse=True)

        for row_n, row in enumerate(table_data):
            self.sig_table.setRowCount(row_n + 1)
            for col_n, col in enumerate(row[:5]):
                pitem = QTableWidgetItem(col)
                self.sig_table.setItem(row_n, col_n, pitem)
            self.sig_table.setCellWidget(row_n, 2, row[7])

        for col_n, col in enumerate(row[:5]):
            self.sig_table.resizeColumnToContents(col_n)

    def pin_edit_cb(self, widget):
        self.generate_cb(preview=True)
        self.request_load_tree = 3
        self.overview_load()
        self.json_preview()

    def pin_table_load(self):
        self.pin_table.setRowCount(0)
        in_use = set()
        table_data = []
        for plugin_instance in self.plugins.plugin_instances:
            name = plugin_instance.plugin_setup.get("name")
            title = plugin_instance.NAME
            if name:
                title = f"{name} ({plugin_instance.NAME})"

            for pin_name, pin_defaults in plugin_instance.PINDEFAULTS.items():
                pin_setup = plugin_instance.plugin_setup.get("pins", {}).get(pin_name, {})
                if not pin_setup and pin_defaults.get("optional") is True:
                    continue
                pin = pin_setup["pin"]
                pin_real = pin

                mapped = ""
                if pin in self.pinmapping_rev:
                    pin_real = self.pinmapping_rev[pin]
                    mapped = pin
                elif pin in self.pinmapping:
                    pin_real = self.pinmapping[pin]
                    mapped = pin

                comment = ""
                modifiers = pin_setup.get("modifier")
                if modifiers:
                    mlist = set()
                    for modifier in modifiers:
                        mlist.add(modifier["type"])
                    comment = f"{','.join(mlist)}"
                in_use.add(pin_real)
                table_data.append((pin_real, title, pin_name, mapped, pin_defaults["direction"], comment))

        for module_data in self.config.get("modules", []):
            slot_name = module_data.get("slot")
            module_name = module_data.get("module")
            title = slot_name
            if module_name:
                title = f"{module_name} ({title})"

            for plugin_instance in self.modules[slot_name]["instances"]:
                name = plugin_instance.plugin_setup.get("name")
                title = plugin_instance.NAME
                if name:
                    title = f"{name} ({plugin_instance.NAME})"

                for pin_name, pin_defaults in plugin_instance.PINDEFAULTS.items():
                    pin_setup = plugin_instance.plugin_setup.get("pins", {}).get(pin_name, {})
                    if not pin_setup and pin_defaults.get("optional") is True:
                        continue

                    pin = pin_setup.get("pin", pin_setup.get("pin_mapped", "???"))
                    pin = f"{slot_name}:{pin}"
                    pin_real = pin

                    mapped = ""
                    if pin in self.pinmapping_rev:
                        pin_real = self.pinmapping_rev[pin]
                        mapped = pin
                    elif pin in self.pinmapping:
                        pin_real = self.pinmapping[pin]
                        mapped = pin

                    comment = ""
                    modifiers = pin_setup.get("modifier")
                    if modifiers:
                        mlist = set()
                        for modifier in modifiers:
                            mlist.add(modifier["type"])
                        comment = f"{','.join(mlist)}"
                    in_use.add(pin_real)
                    table_data.append((pin_real, title, pin_name, mapped, pin_defaults["direction"], comment))

        for pin in self.pinlist:
            if pin not in in_use:
                if pin in self.pinmapping:
                    continue
                if pin in self.pinmapping_rev:
                    if self.pinmapping_rev[pin] in in_use:
                        continue
                in_use.add(pin)
                table_data.append((pin, "", "", "", "", "unused"))

        def sort_key(a):
            col = a[idx]
            numbers = re.findall(r"\d+", col)
            for number in numbers:
                col = col.replace(number, f"{int(number):09d}")
            return col.lower()

        if self.pin_table_sort_col > 0:
            idx = self.pin_table_sort_col - 1
            table_data.sort(key=sort_key)
        elif self.pin_table_sort_col < 0:
            idx = -self.pin_table_sort_col - 1
            table_data.sort(key=sort_key, reverse=True)

        for row_n, row in enumerate(table_data):
            self.pin_table.setRowCount(row_n + 1)
            for col_n, col in enumerate(row):
                pitem = QTableWidgetItem(col)
                self.pin_table.setItem(row_n, col_n, pitem)
        for col_n, col in enumerate(row):
            self.pin_table.resizeColumnToContents(col_n)

    def edit_item(self, obj, key, var_setup=None, cb=None):
        if var_setup is None:
            var_setup = {}
        # if key not in obj and "default" in var_setup:
        #    obj[key] = var_setup["default"]
        if var_setup["type"] == "select":
            return edit_combobox(self, obj, key, var_setup.get("options", []), cb=cb, default=var_setup.get("default"))
        elif var_setup["type"] == int:
            return edit_int(self, obj, key, vmin=var_setup.get("min"), vmax=var_setup.get("max"), cb=cb, default=var_setup.get("default"))
        elif var_setup["type"] == float:
            return edit_float(self, obj, key, vmin=var_setup.get("min"), vmax=var_setup.get("max"), cb=cb, default=var_setup.get("default"))
        elif var_setup["type"] == bool:
            return edit_bool(self, obj, key, cb=cb, default=var_setup.get("default"))
        return edit_text(self, obj, key, cb=cb, default=var_setup.get("default"))

    def load_tree(self):
        while self.model.rowCount() > 0:
            self.model.removeRow(0)

        for key, var_setup in {
            "name": {"type": str},
            "description": {"type": str},
            "boardcfg": {"type": "select", "options": self.boards},
            "protocol": {"type": "select", "options": self.interfaces, "default": "UDP"},
            "axis": {"type": int, "min": 0, "max": 9, "default": 3},
            "machinetype": {"type": "select", "options": ["mill", "lathe"]},
            "gui": {"type": "select", "options": ["axis", "qtdragon", "tklinuxcnc", "touchy", "probe_basic"], "default": "axis"},
        }.items():
            aitem = MyStandardItem()
            self.model.appendRow(
                [
                    MyStandardItem(key.title()),
                    aitem,
                ]
            )
            self.treeview.setIndexWidget(aitem.index(), self.edit_item(self.config, key, var_setup))

        bitem = MyStandardItem()
        self.model.appendRow(
            [
                MyStandardItem("LinuxCNC", help_text="LinuxCNC specific configurations"),
                bitem,
            ]
        )
        tree_lcnc = self.model.item(self.model.rowCount() - 1)
        if "linuxcnc" not in self.config:
            self.config["linuxcnc"] = {}

        bitem = MyStandardItem()
        tree_lcnc.appendRow(
            [
                MyStandardItem("Joypad", help_text="LinuxCNC Joypad-Setup"),
                bitem,
            ]
        )
        tree_lcncjoypad = tree_lcnc.child(tree_lcnc.rowCount() - 1)
        if "joypad" not in self.config["linuxcnc"]:
            self.config["linuxcnc"]["joypad"] = {}
        joypad_config = self.config["linuxcnc"]["joypad"]
        if joypad_config:
            joypad_buttons = ["btn-base", "btn-base2", "btn-top", "btn-top2"]
            for key, var_setup in {
                "enable": {"type": bool, "default": False},
                "name": {"type": str},
                "btn_slow": {"type": "select", "options": joypad_buttons},
                "btn_medium": {"type": "select", "options": joypad_buttons},
                "btn_fast": {"type": "select", "options": joypad_buttons},
            }.items():
                aitem = MyStandardItem()
                tree_lcncjoypad.appendRow(
                    [
                        MyStandardItem(key.title()),
                        aitem,
                    ]
                )
                self.treeview.setIndexWidget(aitem.index(), self.edit_item(joypad_config, key, var_setup))

        bitem = MyStandardItem()
        tree_lcnc.appendRow(
            [
                MyStandardItem("Camera", help_text="LinuxCNC Camera-Setup"),
                bitem,
            ]
        )

        button = QPushButton("add camera")
        button.clicked.connect(self.add_camera)
        button.setMaximumSize(button.sizeHint())
        self.treeview.setIndexWidget(bitem.index(), button)

        tree_lcnccamera = tree_lcnc.child(tree_lcnc.rowCount() - 1)
        if "camera" not in self.config["linuxcnc"]:
            self.config["linuxcnc"]["camera"] = []
        camera_config = self.config["linuxcnc"]["camera"]
        for camera_num, camera in enumerate(camera_config):
            bitem = MyStandardItem()
            tree_lcnccamera.appendRow(
                [
                    MyStandardItem(f"Camera {camera_num}", help_text=f"Camera {camera_num} Setup"),
                    bitem,
                ]
            )
            tree_lcnccamera_n = tree_lcnccamera.child(tree_lcnccamera.rowCount() - 1)

            for key, var_setup in {
                "enable": {"type": bool, "default": False},
                "device": {"type": "str", "default": f"/dev/video{camera_num}"},
                "tabname": {"type": str, "default": f"Camera-{camera_num}"},
            }.items():
                aitem = MyStandardItem()
                tree_lcnccamera_n.appendRow(
                    [
                        MyStandardItem(key.title()),
                        aitem,
                    ]
                )
                self.treeview.setIndexWidget(aitem.index(), self.edit_item(camera, key, var_setup))

            bitem = MyStandardItem()
            tree_lcnccamera_n.appendRow(
                [
                    MyStandardItem("Offset", help_text="Camera offsets"),
                    bitem,
                ]
            )
            tree_lcnccamera_n_offsets = tree_lcnccamera_n.child(tree_lcnccamera_n.rowCount() - 1)
            if "offset" not in camera:
                camera["offset"] = {}

            for offset_axis, offset_var_setup in {
                "X": {"type": int, "default": 0},
                "Y": {"type": int, "default": 0},
                "Z": {"type": int, "default": 0},
                "A": {"type": int, "default": 0},
                "B": {"type": int, "default": 0},
                "C": {"type": int, "default": 0},
                "U": {"type": int, "default": 0},
                "V": {"type": int, "default": 0},
                "W": {"type": int, "default": 0},
            }.items():
                aitem = MyStandardItem()
                tree_lcnccamera_n_offsets.appendRow(
                    [
                        MyStandardItem(offset_axis),
                        aitem,
                    ]
                )
                self.treeview.setIndexWidget(aitem.index(), self.edit_item(camera["offset"], offset_axis, offset_var_setup))

        bitem = MyStandardItem()
        tree_lcnc.appendRow(
            [
                MyStandardItem("INI-Defaults", help_text="LinuxCNC INI-Defaults"),
                bitem,
            ]
        )
        tree_lcncini = tree_lcnc.child(tree_lcnc.rowCount() - 1)
        if "ini" not in self.config["linuxcnc"]:
            self.config["linuxcnc"]["ini"] = {}
        ini_config = self.config["linuxcnc"]["ini"]

        for section, section_data in riocore.generator.LinuxCNC.LinuxCNC.ini_defaults(self.config).items():
            if section not in ini_config:
                ini_config[section] = {}
            section_config = ini_config[section]

            aitem = MyStandardItem()
            tree_lcncini.appendRow(
                [
                    MyStandardItem(section),
                    MyStandardItem(""),
                ]
            )
            lcncsec_view = tree_lcncini.child(tree_lcncini.rowCount() - 1)
            for key, value in section_data.items():
                if value is not None and not isinstance(value, list):
                    var_setup = {"type": type(value), "default": value}
                    if section == "DISPLAY" and key == "POSITION_OFFSET":
                        var_setup["type"] = "select"
                        var_setup["options"] = ["RELATIVE", "MACHINE"]
                    if section == "DISPLAY" and key == "POSITION_FEEDBACK":
                        var_setup["type"] = "select"
                        var_setup["options"] = ["COMMANDED", "ACTUAL"]
                    if section == "HAL" and key == "TWOPASS":
                        var_setup["type"] = "select"
                        var_setup["options"] = ["ON", "OFF"]
                        var_setup["tooltip"] = "Use two pass processing for loading HAL comps."

                    key_title = key
                    if "|" in key:
                        key_title = f"{key.split('|')[0]} ({key.split('|')[1]})"
                    aitem = MyStandardItem()
                    lcncsec_view.appendRow(
                        [
                            MyStandardItem(key_title, help_text=var_setup.get("tooltip")),
                            aitem,
                        ]
                    )
                    self.treeview.setIndexWidget(aitem.index(), self.edit_item(section_config, key, var_setup))

        bitem = MyStandardItem()
        self.model.appendRow(
            [
                MyStandardItem("Modules", help_text="Module-Configuration"),
                bitem,
            ]
        )
        tree_modules = self.model.item(self.model.rowCount() - 1)

        button = QPushButton("add module")
        button.clicked.connect(self.add_module)
        button.setMaximumSize(button.sizeHint())
        self.treeview.setIndexWidget(bitem.index(), button)
        self.treeview.expand(self.model.indexFromItem(tree_modules))

        for module_data in self.config.get("modules", []):
            slot_name = module_data.get("slot")
            module_name = module_data.get("module")
            title = slot_name
            if module_name:
                title = f"{module_name} ({title})"
            aitem = MyStandardItem()
            tree_modules.appendRow(
                [
                    MyStandardItem(title),
                    MyStandardItem(""),
                ]
            )
            module_view = tree_modules.child(tree_modules.rowCount() - 1)
            self.treeview.expand(self.model.indexFromItem(module_view))

            for key, var_setup in {
                "module": {"type": "select", "options": self.module_names},
                "slot": {"type": "select", "options": self.slots},
            }.items():
                aitem = MyStandardItem()
                module_view.appendRow(
                    [
                        MyStandardItem(key.title()),
                        aitem,
                    ]
                )
                self.treeview.setIndexWidget(aitem.index(), self.edit_item(module_data, key, var_setup, cb=self.slot_change))

            module_plugins_view = MyStandardItem("Plugins")
            module_view.appendRow(module_plugins_view)

            # self.treeview.expand(self.model.indexFromItem(module_plugins_view))

            for plugin_instance in self.modules[slot_name]["instances"]:
                self.tree_add_plugin(module_plugins_view, plugin_instance, nopins=True, expand=False)

        bitem = MyStandardItem()
        self.model.appendRow(
            [
                MyStandardItem("Plugins"),
                bitem,
            ]
        )
        self.tree_plugins = self.model.item(self.model.rowCount() - 1)

        button = QPushButton("add plugin")
        button.clicked.connect(self.add_plugin)
        button.setMaximumSize(button.sizeHint())
        self.treeview.setIndexWidget(bitem.index(), button)
        self.treeview.expand(self.model.indexFromItem(self.tree_plugins))

        for plugin_instance in self.plugins.plugin_instances:
            self.tree_add_plugin(self.tree_plugins, plugin_instance)

        self.treeview.header().resizeSection(0, 300)
        self.treeview.header().resizeSection(1, 200)

    def slot_change(self, widget):
        self.config_load()

    def add_modifier(self, parent, pin_setup):
        if "modifier" not in pin_setup:
            pin_setup["modifier"] = []
        modifier_id = len(pin_setup.get("modifier", []))
        pin_setup["modifier"].append({"type": "invert"})
        modifier = pin_setup["modifier"][-1]
        self.tree_add_modifier(parent, pin_setup, modifier_id, modifier)
        self.display()

    def add_plugin(self, widget):
        plugin_type = self.select_plugin()
        if not plugin_type:
            return
        plugin_id = len(self.config["plugins"])
        self.config["plugins"].append(
            {
                "type": plugin_type,
                "pins": {},
            }
        )
        plugin_instance = self.plugins.load_plugin(plugin_id, self.config["plugins"][plugin_id], self.config)
        if plugin_instance:
            for pin_name, pin_defaults in plugin_instance.PINDEFAULTS.items():
                optional = pin_defaults.get("optional")
                if optional is not True:
                    self.config["plugins"][plugin_id]["pins"][pin_name] = {"pin": ""}
                else:
                    self.config["plugins"][plugin_id]["pins"][pin_name] = {"pin": None}
            self.tree_add_plugin(self.tree_plugins, plugin_instance, expand=True)
        self.display()

    def add_camera(self, widget):
        if "camera" not in self.config["linuxcnc"]:
            self.config["linuxcnc"]["camera"] = []
        camera_config = self.config["linuxcnc"]["camera"]
        camera_num = len(camera_config)
        camera_config.append(
            {
                "enable": False,
                "device": f"/dev/video{camera_num}",
                "tabname": f"Camera-{camera_num}",
            }
        )
        self.load_tree()
        self.display()

    def add_module(self, widget):
        while True:
            print("select")
            slot_name, module_name = self.select_module()
            if not module_name or not slot_name:
                print("cancel")
                return

            module_path = self.get_path(f"modules/{module_name}.json")
            moduleJsonStr = open(module_path, "r").read()
            module_defaults = json.loads(moduleJsonStr)

            slot_setup = {}
            for slot in self.board.get("slots", []):
                if slot_name == slot["name"]:
                    slot_setup = slot
            slot_pins = slot_setup.get("pins", {})

            check = True
            for plugin in module_defaults.get("plugins"):
                for pin_name, pin_config in plugin.get("pins", {}).items():
                    pin_location = pin_config.get("pin")
                    print(pin_location, slot_pins)
                    if pin_location not in slot_pins:
                        check = False

            if check is True:
                break
            else:
                print("ERROR: module/slot is not compatible")

        if "modules" not in self.config:
            self.config["modules"] = []

        module_setup = {}
        self.config["modules"].append(
            {
                "slot": slot_name,
                "module": module_name,
                "setup": module_setup,
            }
        )
        print("module_instance", self.config["modules"])

        mplugins = riocore.Plugins()
        for plugin_id, plugin_config in enumerate(module_defaults.get("plugins", [])):
            plugin_name = plugin_config.get("name")
            if plugin_name not in module_setup:
                module_setup[plugin_name] = {}
            self.setup_merge(module_setup[plugin_name], plugin_config)
            if "pins" in module_setup[plugin_name]:
                for pin in module_setup[plugin_name]["pins"]:
                    module_setup[plugin_name]["pins"][pin]["pin_mapped"] = module_setup[plugin_name]["pins"][pin]["pin"]
                    del module_setup[plugin_name]["pins"][pin]["pin"]

            mplugins.load_plugin(plugin_id, module_setup[plugin_name], self.config)

        self.modules[slot_name] = {
            "defaults": module_defaults,
            "setup": module_setup,
            "instances": mplugins.plugin_instances,
        }

        self.config_load()

    def del_plugin(self, plugin_instance, plugin_id, widget):
        self.config["plugins"].pop(plugin_id)
        self.config_load()
        self.display()

    def config_plugin(self, plugin_instance, plugin_id, widget):
        if os.path.isfile(f"{riocore_path}/plugins/{plugin_instance.NAME}/config.py"):
            plugin_config = importlib.import_module(".config", f"riocore.plugins.{plugin_instance.NAME}")
            config_box = plugin_config.config(plugin_instance, styleSheet=STYLESHEET)
            config_box.run()
        self.config_load()
        self.load_tree()
        self.display()

    def select_plugin(self):
        def change(combo, info, description, selected):
            plugin_name = combo.currentText()
            plugins = riocore.Plugins()
            plugins.load_plugins({"plugins": [{"type": plugin_name}]})
            infotext = plugins.plugin_instances[0].INFO
            info.setText(infotext)
            descriptiontext = plugins.plugin_instances[0].DESCRIPTION
            description.clear()
            description.insertPlainText(descriptiontext)

        plugin_list = self.plugins.list()
        plugins = riocore.Plugins()
        plugins.load_plugins({"plugins": [{"type": plugin_list[0]["name"]}]})
        infotext = plugins.plugin_instances[0].INFO
        descriptiontext = plugins.plugin_instances[0].DESCRIPTION

        dialog = QDialog()
        dialog.setWindowTitle("add Plugin")
        dialog.setFixedWidth(500)
        dialog.setFixedHeight(400)
        dialog.setStyleSheet(STYLESHEET)

        dialog.buttonBox = QDialogButtonBox(QDialogButtonBox.Ok)
        dialog.buttonBox.accepted.connect(dialog.accept)

        dialog.layout = QVBoxLayout()

        hlayout = QHBoxLayout()

        vlayout_left = QVBoxLayout()

        message = QLabel("Plugin-Type:")
        vlayout_left.addWidget(message)
        combo = QComboBox(self)
        for plugin in plugin_list:
            combo.addItem(plugin["name"])
        vlayout_left.addWidget(combo)
        vlayout_left.addStretch()

        vlayout = QVBoxLayout()
        info = QLabel(infotext)
        vlayout.addWidget(info)

        description = QPlainTextEdit()
        description.clear()
        description.insertPlainText(descriptiontext)

        vlayout.addWidget(description)

        hlayout.addLayout(vlayout_left)
        hlayout.addLayout(vlayout)

        dialog.layout.addLayout(hlayout)

        cb = partial(change, combo, info, description)
        combo.activated.connect(cb)

        dialog.layout.addWidget(dialog.buttonBox)
        dialog.setLayout(dialog.layout)

        if dialog.exec():
            return combo.currentText()

    def select_module(self):
        dialog = QDialog()
        dialog.setWindowTitle("add Module")
        dialog.setStyleSheet(STYLESHEET)

        dialog.buttonBox = QDialogButtonBox(QDialogButtonBox.Ok)
        dialog.buttonBox.accepted.connect(dialog.accept)

        dialog.layout = QVBoxLayout()
        message = QLabel("Slot:")
        dialog.layout.addWidget(message)
        combo_slot = QComboBox(self)

        message = QLabel("Module:")
        dialog.layout.addWidget(message)
        combo_module = QComboBox(self)

        for slot in self.board.get("slots", []):
            slot_name = slot["name"]
            if slot_name not in self.modules:
                combo_slot.addItem(slot_name)
        dialog.layout.addWidget(combo_slot)

        for module in self.module_names:
            combo_module.addItem(module)
        dialog.layout.addWidget(combo_module)

        dialog.layout.addWidget(dialog.buttonBox)
        dialog.setLayout(dialog.layout)

        if dialog.exec():
            return (combo_slot.currentText(), combo_module.currentText())

    def flash_cb(self):
        self.tabwidget.setCurrentWidget(self.gateware_tabwidget)
        self.gateware_tabwidget.setCurrentWidget(self.gateware["Flash-Output"])

        widget = self.gateware["Flash-Output"]
        config_name = self.config.get("name")
        widget.clear()
        widget.insertPlainText("...")

        self.flash_start = time.time()
        self.flash_sub = subprocess.Popen(f"(cd Output/{config_name}/Gateware/ ; make load 2>&1 | tee flash.log)", shell=True, close_fds=True)
        self.button_flash.setEnabled(False)
        self.info_widget.setText("flashing...")

    def compile_cb(self):
        self.tabwidget.setCurrentWidget(self.gateware_tabwidget)
        self.gateware_tabwidget.setCurrentWidget(self.gateware["Compile-Output"])

        widget = self.gateware["Compile-Output"]
        config_name = self.config.get("name")
        widget.clear()
        widget.insertPlainText("...")

        self.compile_start = time.time()
        self.compile_sub = subprocess.Popen(f"(cd Output/{config_name}/Gateware/ ; make clean all 2>&1 | tee compile.log)", shell=True, close_fds=True)
        self.button_compile.setEnabled(False)
        self.info_widget.setText("compiling...")

    def generate_cb(self, preview=False):
        self.info_widget.setText("generate...")
        output_path = "Output"
        if preview:
            output_path = "OutputTMP"
        config_name = self.config.get("name")
        self.generate(output_path, preview=preview)
        try:
            for filename, widget in self.gateware.items():
                if not filename.endswith("-Output"):
                    file_content = open(f"{output_path}/{config_name}/Gateware/{filename}", "r").read()
                    widget.clear()
                    widget.insertPlainText(file_content)
                    if filename == "rio.v":
                        hash_md5 = hashlib.md5()
                        hash_md5.update(file_content.encode())
                        self.gateware_hash = hash_md5.hexdigest()

            for filename, widget in self.linuxcnc.items():
                if filename == "rio.c":
                    file_content = open(f"{output_path}/{config_name}/LinuxCNC/Component/{filename}", "r").read()
                else:
                    file_content = open(f"{output_path}/{config_name}/LinuxCNC/Configuration/{filename}", "r").read()
                widget.clear()
                widget.insertPlainText(file_content)
        except Exception as error:
            print(f"ERROR loading output: {error}")
        if preview:
            os.system(f"rm -rf {output_path}/")
        self.info_widget.setText("generate...done")

    def generate(self, output_path=None, preview=False):
        config = self.clean_config(self.config)
        if not output_path:
            output_path = "Output"
        try:
            if preview:
                open(f"{self.config_file}_tmp.json", "w").write(json.dumps(config, indent=4))
                os.system(f"{riocore_path}/../bin/rio-generator -p {self.config_file}_tmp.json {output_path} >/dev/null")
                os.system(f"rm {self.config_file}_tmp.json")
            else:
                os.system(f"{riocore_path}/../bin/rio-generator {self.config_file} {output_path}")
                self.check_status()
        except Exception as error:
            print(f"ERROR generating output: {error}")

    def save_config_as(self, widget=None):
        file_dialog = QFileDialog(self)
        file_dialog.setNameFilters(["json (*.json)"])
        name = file_dialog.getSaveFileName(self, "Save File", self.config_file, "json (*.json)")
        if name[0]:
            self.save_config(name[0])
            self.config_file = name[0]
            self.config_original = self.clean_config(self.config)
            self.info_widget.setText(f"Saved as: {os.path.basename(name[0])}")
            self.check_status()

    def save_config_cb(self):
        self.save_config(self.config_file)
        self.config_original = self.clean_config(self.config)
        self.info_widget.setText(f"Saved as: {os.path.basename(self.config_file)}")
        self.check_status()

    def save_config(self, filename):
        config = self.clean_config(self.config)
        open(filename, "w").write(json.dumps(config, indent=4))

    def tree_add_plugin(self, parent, plugin_instance, nopins=False, expand=False):
        name = plugin_instance.plugin_setup.get("name")
        title = plugin_instance.NAME
        if name:
            title = f"{name} ({plugin_instance.NAME})"

        help_text = plugin_instance.INFO

        aitem = MyStandardItem()
        parent.appendRow(
            [
                MyStandardItem(title, help_text=help_text),
                aitem,
            ]
        )

        buttons_layout = QHBoxLayout()
        buttons_layout.setContentsMargins(0, 0, 0, 0)
        buttons_widget = QWidget()
        buttons_widget.setLayout(buttons_layout)

        button_delete = QPushButton("delete")
        cb = partial(self.del_plugin, plugin_instance, plugin_instance.plugin_id)
        button_delete.clicked.connect(cb)
        button_delete.setMaximumSize(button_delete.sizeHint())
        buttons_layout.addWidget(button_delete)
        if plugin_instance.PLUGIN_CONFIG:
            button_config = QPushButton("config")
            cb = partial(self.config_plugin, plugin_instance, plugin_instance.plugin_id)
            button_config.clicked.connect(cb)
            button_config.setMaximumSize(button_config.sizeHint())
            buttons_layout.addWidget(button_config)
        buttons_layout.addStretch()
        self.treeview.setIndexWidget(aitem.index(), buttons_widget)

        plugin_view = parent.child(parent.rowCount() - 1)
        self.tree_add_options(plugin_view, plugin_instance, expand=expand)
        self.tree_add_pins(plugin_view, plugin_instance, expand=expand, nopins=nopins)
        if plugin_instance.TYPE == "joint" and plugin_instance.plugin_setup.get("is_joint", False):
            self.tree_add_joint(plugin_view, plugin_instance, expand=expand)
            if plugin_instance.SIGNALS:
                self.tree_add_signals(plugin_view, plugin_instance, expand=expand)
        else:
            if plugin_instance.SIGNALS:
                self.tree_add_signals(plugin_view, plugin_instance, expand=expand)
        if expand:
            self.treeview.expand(self.model.indexFromItem(plugin_view))

    def callback_plugin_name(self, parent, plugin_instance, value):
        parent.setText(f"{value} ({plugin_instance.NAME})")

    def tree_add_options(self, parent, plugin_instance, expand=False):
        for option_name, option_defaults in plugin_instance.OPTIONS.items():
            title = option_name.title()
            unit = option_defaults.get("unit")
            if unit:
                title = f"{title} ({unit})"
            help_text = option_defaults.get("description", title)
            aitem = MyStandardItem()
            parent.appendRow(
                [
                    MyStandardItem(title, help_text=help_text),
                    aitem,
                ]
            )
            cb = partial(self.callback_plugin_name, parent, plugin_instance)
            self.treeview.setIndexWidget(aitem.index(), self.edit_item(plugin_instance.plugin_setup, option_name, option_defaults, cb=cb))

            options_view = parent.child(parent.rowCount() - 1)
            if expand:
                self.treeview.expand(self.model.indexFromItem(options_view))

    def tree_add_modifier(self, parent, pin_setup, modifier_id, modifier):
        mitem = MyStandardItem()
        parent.appendRow(
            [
                MyStandardItem("Modifier"),
                mitem,
                MyStandardItem(""),
            ]
        )
        modifier_view = parent.child(parent.rowCount() - 1)
        self.treeview.setIndexWidget(mitem.index(), modifier_selector(self, pin_setup, modifier_id, modifier_view))

    def tree_add_signals(self, parent, plugin_instance, expand=False):
        signals_view = MyStandardItem("Signals", help_text="signal-configuration for this plugin instance")
        parent.appendRow(signals_view)
        if expand:
            self.treeview.expand(self.model.indexFromItem(signals_view))

        if "signals" not in plugin_instance.plugin_setup:
            plugin_instance.plugin_setup["signals"] = {}
        signals_setup = plugin_instance.plugin_setup["signals"]

        for signal_name, signal_defaults in plugin_instance.SIGNALS.items():
            if signal_name not in signals_setup:
                signals_setup[signal_name] = {}
            help_text = f"{signal_name} config"

            signal_view = MyStandardItem(signal_name, help_text="signal-configuration for this plugin instance")
            signals_view.appendRow(signal_view)
            if expand:
                self.treeview.expand(self.model.indexFromItem(signal_view))

            signal_setup = signal_defaults.get("setup", {})
            signal_direction = signal_defaults["direction"]
            is_bool = signal_defaults.get("bool", False)

            options = []
            for halpin, halpin_info in halpins.LINUXCNC_SIGNALS[signal_direction].items():
                if is_bool:
                    if halpin_info.get("type") == bool:
                        options.append(halpin)
                elif halpin_info.get("type") != bool:
                    options.append(halpin)

            signal_setup["net"] = {"type": "select", "options": options}
            signal_setup["function"] = {"type": str}
            if signal_direction == "output":
                signal_setup["setp"] = {"type": str, "default": ""}

            for option, option_setup in signal_setup.items():
                help_text = f"{option} config"
                citem = MyStandardItem()
                signal_view.appendRow(
                    [
                        MyStandardItem(option, help_text=help_text),
                        citem,
                    ]
                )
                signal_option_view = signal_view.child(signal_view.rowCount() - 1)
                cb = None
                self.treeview.setIndexWidget(citem.index(), self.edit_item(signals_setup[signal_name], option, option_setup, cb=cb))
                if expand:
                    self.treeview.expand(self.model.indexFromItem(signal_option_view))

            display_view = MyStandardItem("Display", help_text="display-configuration for this signal")
            signal_view.appendRow(display_view)
            if expand:
                self.treeview.expand(self.model.indexFromItem(display_view))

            if signal_defaults["direction"] == "input" or signals_setup[signal_name].get("net"):
                if signal_defaults.get("bool"):
                    type_options = ["none", "led", "rectled"]
                else:
                    type_options = ["none", "number", "bar", "meter"]
            else:
                if signal_defaults.get("bool"):
                    type_options = ["none", "checkbutton", "button"]
                else:
                    type_options = ["none", "scale", "spinbox", "dial", "jogwheel"]

            if "display" not in signals_setup[signal_name]:
                signals_setup[signal_name]["display"] = {}

            for option, option_setup in {"title": {"type": str}, "section": {"type": str}, "type": {"type": "select", "options": type_options}}.items():
                help_text = f"{option} config"
                citem = MyStandardItem()
                display_view.appendRow(
                    [
                        MyStandardItem(option, help_text=help_text),
                        citem,
                    ]
                )
                signal_option_view = display_view.child(display_view.rowCount() - 1)
                cb = None
                self.treeview.setIndexWidget(citem.index(), self.edit_item(signals_setup[signal_name]["display"], option, option_setup, cb=cb))
                if expand:
                    self.treeview.expand(self.model.indexFromItem(signal_option_view))

    def tree_add_joint(self, parent, plugin_instance, expand=False):
        joint_view = MyStandardItem("Joint", help_text="joint-configuration for this plugin instance")
        parent.appendRow(joint_view)
        if expand:
            self.treeview.expand(self.model.indexFromItem(joint_view))

        if "joint" not in plugin_instance.plugin_setup:
            plugin_instance.plugin_setup["joint"] = {}
        joints_setup = plugin_instance.plugin_setup["joint"]

        joint_options = {
            "scale": {
                "type": float,
            },
            "type": {
                "type": "select",
                "options": ["LINEAR", "ROTARY"],
            },
            "home": {
                "type": float,
            },
            "home_sequence": {
                "type": int,
            },
            "min_limit": {
                "type": float,
            },
            "max_limit": {
                "type": float,
            },
            "max_velocity": {
                "type": float,
            },
            "max_acceleration": {
                "type": float,
            },
            "stepgen_maxaccel": {
                "type": float,
            },
            "home_search_vel": {
                "type": float,
            },
            "home_latch_vel": {
                "type": float,
            },
            "home_final_vel": {
                "type": float,
            },
            "home_offset": {
                "type": float,
            },
            "home_ignore_limits": {
                "type": "select",
                "options": ["YES", "NO"],
            },
            "home_use_index": {
                "type": "select",
                "options": ["YES", "NO"],
            },
        }

        for key, value in riocore.generator.LinuxCNC.LinuxCNC.JOINT_DEFAULTS.items():
            key = key.lower()
            if key == "scale_out":
                key = "scale"
            if key in joint_options:
                joint_options[key.lower()]["default"] = value

        for option, option_setup in joint_options.items():
            help_text = f"{option} config"
            citem = MyStandardItem()
            joint_view.appendRow(
                [
                    MyStandardItem(option, help_text=help_text),
                    citem,
                ]
            )
            joint_option_view = joint_view.child(joint_view.rowCount() - 1)
            # cb = partial(self.callback_plugin_name, parent, plugin_instance)
            cb = None
            self.treeview.setIndexWidget(citem.index(), self.edit_item(joints_setup, option, option_setup, cb=cb))
            if expand:
                self.treeview.expand(self.model.indexFromItem(joint_option_view))

    def tree_add_pins(self, parent, plugin_instance, expand=False, nopins=False):
        pins_view = MyStandardItem("Pins", help_text="pin-configuration for this plugin instance")
        parent.appendRow(pins_view)
        if expand:
            self.treeview.expand(self.model.indexFromItem(pins_view))
        for pin_name, pin_defaults in plugin_instance.PINDEFAULTS.items():
            pin_setup = plugin_instance.plugin_setup.get("pins", {}).get(pin_name, {})
            direction = pin_defaults["direction"]
            optional = pin_defaults.get("optional")
            help_text = f"pin location for {direction} pin: {pin_name}"
            if optional:
                help_text = f"{help_text} (optional)"

            pin_title = f"{pin_name} ({direction})"
            citem = MyStandardItem()
            pins_view.appendRow(
                [
                    MyStandardItem(pin_title, help_text=help_text),
                    citem,
                ]
            )
            if not nopins:
                self.treeview.setIndexWidget(citem.index(), self.edit_item(pin_setup, "pin", {"type": "select", "options": self.pinlist, "default": ""}))

            pin_view = pins_view.child(pins_view.rowCount() - 1)
            if expand:
                self.treeview.expand(self.model.indexFromItem(pin_view))

            if direction == "input":
                pitem = MyStandardItem()
                pin_view.appendRow(
                    [
                        MyStandardItem("Pullup", help_text="activate pullup resistor for this pin"),
                        pitem,
                    ]
                )
                self.treeview.setIndexWidget(pitem.index(), self.edit_item(pin_setup, "pullup", {"type": bool}))

            bitem = MyStandardItem()
            pin_view.appendRow(
                [
                    MyStandardItem("Modifiers", help_text="pin modifier chain"),
                    bitem,
                ]
            )
            button = QPushButton("add")
            button.setMaximumSize(button.sizeHint())
            self.treeview.setIndexWidget(bitem.index(), button)
            modifiers_view = pin_view.child(pin_view.rowCount() - 1)
            button.clicked.connect(partial(self.add_modifier, modifiers_view, pin_setup))
            if expand:
                self.treeview.expand(self.model.indexFromItem(modifiers_view))

            for modifier_id, modifier in enumerate(pin_setup.get("modifier", [])):
                self.tree_add_modifier(modifiers_view, pin_setup, modifier_id, modifier)
            self.treeview.expand(self.model.indexFromItem(modifiers_view))


if __name__ == "__main__":
    app = QApplication(sys.argv)

    parser = argparse.ArgumentParser()
    parser.add_argument("config", help="config", nargs="?", type=str, default=None)
    args = parser.parse_args()

    form = WinForm(args)
    form.show()
    sys.exit(app.exec_())
